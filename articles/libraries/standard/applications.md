---
title: 'Q # 标准库-应用程序 |Microsoft Docs'
description: Q# 标准库
author: QuantumWriter
uid: microsoft.quantum.libraries.applications
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: ef22460a5bca63ebaf32c0ba21984e103ec8ebdd
ms.sourcegitcommit: 27c9bf1aae923527aa5adeaee073cb27d35c0ca1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/05/2019
ms.locfileid: "74864383"
---
# <a name="applications"></a><span data-ttu-id="8da1b-103">应用程序</span><span class="sxs-lookup"><span data-stu-id="8da1b-103">Applications</span></span> #

## <a name="hamiltonian-simulation"></a><span data-ttu-id="8da1b-104">哈密顿模拟</span><span class="sxs-lookup"><span data-stu-id="8da1b-104">Hamiltonian Simulation</span></span> ##

<span data-ttu-id="8da1b-105">量程系统的模拟是最令人兴奋的量程计算应用程序之一。</span><span class="sxs-lookup"><span data-stu-id="8da1b-105">The simulation of quantum systems is one of the most exciting applications of quantum computation.</span></span>
<span data-ttu-id="8da1b-106">在传统计算机上，模拟量程机制的难点通常是使用其状态向量表示形式的维度 $N $ 进行缩放。</span><span class="sxs-lookup"><span data-stu-id="8da1b-106">On a classical computer, the difficulty of simulating quantum mechanics, in general, scales with the dimension $N$ of its state-vector representation.</span></span>
<span data-ttu-id="8da1b-107">由于此表示形式与 $n $ qubits $N = 2 ^ n $ 的数量呈指数级增长，因此，埋怨是一种称为 "[维数](xref:microsoft.quantum.concepts.multiple-qubits)" 的特征，而经典硬件上的量程模拟是棘手。</span><span class="sxs-lookup"><span data-stu-id="8da1b-107">As this representation grows exponentially with the number of $n$ qubits $N=2^n$, a trait known also known as the [curse of dimensionality](xref:microsoft.quantum.concepts.multiple-qubits), quantum simulation on classical hardware is intractable.</span></span>

<span data-ttu-id="8da1b-108">但是，这种情况在量程硬件上可能会有很大的差异。</span><span class="sxs-lookup"><span data-stu-id="8da1b-108">However, the situation can be very different on quantum hardware.</span></span> <span data-ttu-id="8da1b-109">量程模拟的最常见变化形式称为与时间无关的 Hamiltonian 模拟问题。</span><span class="sxs-lookup"><span data-stu-id="8da1b-109">The most common variation of quantum simulation is called the time-independent Hamiltonian simulation problem.</span></span> <span data-ttu-id="8da1b-110">其中，提供了系统 Hamiltonian $H $ 的说明，它是一个 Hermitian 矩阵，另一个最初的量程状态 $ \ket{\psi （0）} $，是在量程计算机上 $n $ qubits 进行编码的。</span><span class="sxs-lookup"><span data-stu-id="8da1b-110">There, one is provided with a description of the system Hamiltonian $H$, which is a Hermitian matrix, and some initial quantum state $\ket{\psi(0)}$ that is encoded in some basis on $n$ qubits on a quantum computer.</span></span> <span data-ttu-id="8da1b-111">由于关闭的系统中的量程状态在 Schrödinger 等式 $ $ \begin{align} i\frac {d \ket{\psi （t）}} {d t} & = H \ket{\psi （t）}、\end{align} $ $ 下发展，因此目标是在某个固定时间实现单一时间演化运算符 $U （t） = e ^ {-iHt} $ $t $，其中 $ \ket{\psi （t）} = U （t） \ket{\psi （0）} $ 将求解 Schrödinger 公式。</span><span class="sxs-lookup"><span data-stu-id="8da1b-111">As quantum states in closed systems evolve under the Schrödinger equation $$ \begin{align} i\frac{d \ket{\psi(t)}}{d t} & = H \ket{\psi(t)}, \end{align} $$ the goal is to implement the unitary time-evolution operator $U(t)=e^{-iHt}$ at some fixed time $t$, where $\ket{\psi(t)}=U(t)\ket{\psi(0)}$ solves the Schrödinger equation.</span></span>
<span data-ttu-id="8da1b-112">类似，依赖于时间的 Hamiltonian 模拟问题解决了同一公式，但 $H （t） $ 现在为时间函数。</span><span class="sxs-lookup"><span data-stu-id="8da1b-112">Analogously, the time-dependent Hamiltonian simulation problem solves the same equation, but with $H(t)$ now a function of time.</span></span>

<span data-ttu-id="8da1b-113">Hamiltonian 模拟是许多其他量子模拟问题的主要组成部分，而 Hamiltonian 模拟问题的解决方案是一种算法，用于描述综合 a 逼近单一 $ \tilde{U}\\\\$ 的一系列的[spectral 标准](xref:microsoft.quantum.concepts.matrix-advanced)中的 \le \epsilon $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-113">Hamiltonian simulation is a major component of many other quantum simulation problems, and solutions to Hamiltonian simulation problem are algorithms that describes a sequence of primitive quantum gates for synthesizing an approximating unitary $\tilde{U}$ with error $\\|\tilde{U} - U(t)\\| \le \epsilon$ in the [spectral norm](xref:microsoft.quantum.concepts.matrix-advanced).</span></span> <span data-ttu-id="8da1b-114">这些算法的复杂性非常严格地取决于量程计算机如何访问相关 Hamiltonian 的说明。</span><span class="sxs-lookup"><span data-stu-id="8da1b-114">The complexity of these algorithms depend very strongly on how a description of the Hamiltonian of interest is made accessible by a quantum computer.</span></span> <span data-ttu-id="8da1b-115">例如，在最坏情况下，如果要将 $H $ $n $ qubits 上的 $ 提供为 $ 2 ^ n \times 2 ^ n $ 数字的列表，每个矩阵元素对应一个矩阵元素，只需读取数据就会需要指数时间。</span><span class="sxs-lookup"><span data-stu-id="8da1b-115">For instance, in the worst-case, if $H$ acting on $n$ qubits were to be provided as a list of $2^n \times 2^n$ numbers, one for each matrix element, simply reading the data would already require exponential time.</span></span> <span data-ttu-id="8da1b-116">在最佳情况下，可能会假设有权访问 $O \ket{t}\ket{\psi （0）} = \ket{t}U （t） \ket{\psi （0）} $ 完全的黑色框。</span><span class="sxs-lookup"><span data-stu-id="8da1b-116">In the best case, one could assume access to a black-box unitary that $O\ket{t}\ket{\psi(0)}=\ket{t}U(t)\ket{\psi(0)}$ trivially solves the problem.</span></span> <span data-ttu-id="8da1b-117">这两个输入模型都不是特别感兴趣的，即前者不能比传统方法更好，而后者则隐藏其实现的基元门复杂度，这在 qubits 数中可能是指数的。</span><span class="sxs-lookup"><span data-stu-id="8da1b-117">Neither of these input models are particularly interesting -- the former as it is no better than classical approaches, and the latter as the black-box hides the primitive gate complexity of its implementation, which could be exponential in the number of qubits.</span></span>

### <a name="descriptions-of-hamiltonians"></a><span data-ttu-id="8da1b-118">Hamiltonians 的说明</span><span class="sxs-lookup"><span data-stu-id="8da1b-118">Descriptions of Hamiltonians</span></span> ###

<span data-ttu-id="8da1b-119">因此需要输入格式的其他假设。</span><span class="sxs-lookup"><span data-stu-id="8da1b-119">Additional assumptions of the format of the input are therefore required.</span></span> <span data-ttu-id="8da1b-120">精细平衡在输入模型之间必须是有意义的，这两个输入模型对包含感兴趣的 Hamiltonians （如那些实际的物理系统或相关的计算问题）和具有足够限制的输入模型在量程计算机上有效实施。</span><span class="sxs-lookup"><span data-stu-id="8da1b-120">A fine balance must be struck between input models that are sufficiently descriptive to encompass interesting Hamiltonians, such as those for realistic physical systems or interesting computational problems, and input models that are sufficiently restrictive to be efficiently implementable on a quantum computer.</span></span> <span data-ttu-id="8da1b-121">在该宣传资料中可以找到各种非常重要的输入模型，范围从量子到古典。</span><span class="sxs-lookup"><span data-stu-id="8da1b-121">A variety of non-trivial input model may be found in the literature, and they range from quantum to classical.</span></span> 

<span data-ttu-id="8da1b-122">作为量程输入模型的示例，[基于样本的 Hamiltonian 模拟](http://www.nature.com/articles/s41534-017-0013-7)假定对生成密度矩阵 $ \rho $ （被视为 Hamiltonian $H $）副本的量程操作具有黑白访问。</span><span class="sxs-lookup"><span data-stu-id="8da1b-122">As examples of quantum input models, [sample-based Hamiltonian simulation](http://www.nature.com/articles/s41534-017-0013-7) assumes black-box access to quantum operations that produce copies of a density matrix $\rho$, which are taken to be the Hamiltonian $H$.</span></span> <span data-ttu-id="8da1b-123">在[单一访问模型](https://arxiv.org/abs/1202.5822)中，将 Hamiltonian 分解为 unitaries $ $ \begin{align} H & = \sum ^ {d}\_{j = 0}\_j \hat{U}\_j，\end{align} $ $，其中 $a\_j > 0 $ 是系数，$ \hat{U}\_j $ 为 unitaries。</span><span class="sxs-lookup"><span data-stu-id="8da1b-123">In the [unitary access model](https://arxiv.org/abs/1202.5822) one supposes that the Hamiltonian instead decomposes into a sum of unitaries $$ \begin{align} H & = \sum^{d-1}\_{j=0} a\_j \hat{U}\_j, \end{align} $$ where $a\_j>0$ are coefficients, and $\hat{U}\_j$ are unitaries.</span></span> <span data-ttu-id="8da1b-124">然后假设有一个对单一 oracle $V = \sum ^ {d}\_{j = 0} \ket{j}\bra{j}\otimes \hat{U}\_j $ 的黑白访问，该选择所需的 $ \hat{U}\_j $，和 oracle $A \ket{0}= \sum ^ {d-1}\_{j = 0} \sqrt{a\_j/\ sum ^ {d-1}\_{k = 0} \alpha\_j} \ket{j} $，用于创建量程状态编码这些系数。</span><span class="sxs-lookup"><span data-stu-id="8da1b-124">It is then assumed that one has black-box access to the unitary oracle $V=\sum^{d-1}\_{j=0}\ket{j}\bra{j}\otimes \hat{U}\_j$ that selects the desired $\hat{U}\_j$, and the oracle $A\ket{0}=\sum^{d-1}\_{j=0}\sqrt{a\_j/\sum^{d-1}\_{k=0}\alpha\_j}\ket{j}$ that create a quantum state encoding these coefficients.</span></span> <span data-ttu-id="8da1b-125">对于[稀疏 Hamiltonian 模拟](https://arxiv.org/abs/quant-ph/0301023)，一种假设 Hamiltonian 是一个稀疏矩阵，其中每一行只包含 $d = \mathcal{O} （\Text{polylog} （N）） $ 非零元素。</span><span class="sxs-lookup"><span data-stu-id="8da1b-125">In the case of [sparse Hamiltonian simulation](https://arxiv.org/abs/quant-ph/0301023), one assumes that the Hamiltonian is a sparse matrix with only $d=\mathcal{O}(\text{polylog}(N))$ non-zero element in every row.</span></span> <span data-ttu-id="8da1b-126">此外，还假定存在有效的量程线路，它们输出了这些非零元素的位置以及它们的值。</span><span class="sxs-lookup"><span data-stu-id="8da1b-126">Moreover, one assumes the existence of efficient quantum circuits that output the location of these non-zero elements, as well as the their values.</span></span> <span data-ttu-id="8da1b-127">[Hamiltonian 模拟算法](xref:microsoft.quantum.more-information)的复杂性是根据对这些黑色框进行查询的数量来计算的，因此，基元入口的复杂性很大程度上取决于实现这些黑框的难度。</span><span class="sxs-lookup"><span data-stu-id="8da1b-127">The complexity of [Hamiltonian simulation algorithms](xref:microsoft.quantum.more-information) is evaluated in terms of number of queries to these black-boxes, and the primitive gate complexity then depends very much on the difficulty of implementing these black-boxes.</span></span>

> [!NOTE]
> <span data-ttu-id="8da1b-128">大 O 表示法通常用于描述算法的复杂性缩放。</span><span class="sxs-lookup"><span data-stu-id="8da1b-128">The big-O notation is commonly used to describe the complexity scaling of algorithms.</span></span> <span data-ttu-id="8da1b-129">假设有两个真正的函数 $f，g $，表达式 $g （x） = \mathcal{O} （f （x）） $ 表示存在绝对正值 $x\_0，c > 0 $，$g （x） \le c f （x） $ 表示所有 $x \ge x\_$0。</span><span class="sxs-lookup"><span data-stu-id="8da1b-129">Given two real functions $f,g$, the expression $g(x)=\mathcal{O}(f(x))$ means that there exists an absolute positive constant $x\_0, c>0$ such that $g(x) \le c f(x)$ for all $x\ge x\_0$.</span></span> 

<span data-ttu-id="8da1b-130">在量程计算机上要实现的大多数实际应用程序中，这些黑框必须有效地实施，这是 $ \mathcal{O} （\text{polylog} （N）） $ 基元量子入口。</span><span class="sxs-lookup"><span data-stu-id="8da1b-130">In most practical applications to be implemented on a quantum computer, these black-boxes must be efficiently implementable, that is with $\mathcal{O}(\text{polylog}(N))$ primitive quantum gates.</span></span> <span data-ttu-id="8da1b-131">更强、更有效的 simulable Hamiltonians 必须具有足够的稀疏传统说明。</span><span class="sxs-lookup"><span data-stu-id="8da1b-131">More strongly, efficiently simulable Hamiltonians must have some sufficiently sparse classical description.</span></span> <span data-ttu-id="8da1b-132">在这种情况下，假定将 Hamiltonian 分解为 Hermitian part $ $ \begin{align} H 的总和 part $ $ H & = \sum ^ {d-1} _ {j = 0} H_j。</span><span class="sxs-lookup"><span data-stu-id="8da1b-132">In one such formulation, it is assumed that the Hamiltonian decomposes into a sum of Hermitian parts $$ \begin{align} H & = \sum^{d-1}_{j=0} H_j.</span></span>
<span data-ttu-id="8da1b-133">\end{align} $ $ 而且，假设每个部件（Hamiltonian $H\_j $）都易于模拟。</span><span class="sxs-lookup"><span data-stu-id="8da1b-133">\end{align} $$ Moreover, it is assumed that each part, a Hamiltonian $H\_j$, is easy to simulate.</span></span> <span data-ttu-id="8da1b-134">这意味着任何时候都可以使用 $ \mathcal{O} （1） $ 基元量子入口来完全实现 $t $ 的单一 $e ^ {-iH\_j t} $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-134">This means that the unitary $e^{-iH\_j t}$ for any time $t$ may be implemented exactly using $\mathcal{O}(1)$ primitive quantum gates.</span></span> <span data-ttu-id="8da1b-135">例如，这在特殊情况下为 true，其中每个 $H\_j $ 是 local Pauli 运算符，这意味着它们属于 tensor products of $ \mathcal{O} （1） $ 非标识 Pauli operators，它们作用于空间关闭的 qubits。</span><span class="sxs-lookup"><span data-stu-id="8da1b-135">For instance, this is true in the special case where each $H\_j$ are local Pauli operators, meaning that they are of tensor products of $\mathcal{O}(1)$ non-identity Pauli operators that act on spatially close qubits.</span></span> <span data-ttu-id="8da1b-136">此模型特别适用于具有受限和本地交互的物理系统，因为术语数为 $d = \mathcal{O} （\text{polylog} （N）） $，并且可能会在多项式时间内清楚地写出，即经典。</span><span class="sxs-lookup"><span data-stu-id="8da1b-136">This model is particularly applicable to physical systems with bounded and local interaction, as the number of terms is $d=\mathcal{O}(\text{polylog}(N))$, and may clearly be written down, i.e. classically described, in polynomial time.</span></span>

> [!TIP]
> <span data-ttu-id="8da1b-137">可以使用 Dynamical 生成器表示库来描述分解到部分的 Hamiltonians。</span><span class="sxs-lookup"><span data-stu-id="8da1b-137">Hamiltonians that decompose into a sum of parts may be described using the Dynamical Generator Representation library.</span></span> <span data-ttu-id="8da1b-138">有关详细信息，请参阅[数据结构](xref:microsoft.quantum.libraries.data-structures)中的 Dynamical 生成器表示形式部分。</span><span class="sxs-lookup"><span data-stu-id="8da1b-138">For more information, see the Dynamical Generator Representation section in [data structures](xref:microsoft.quantum.libraries.data-structures).</span></span>

### <a name="simulation-algorithms"></a><span data-ttu-id="8da1b-139">模拟算法</span><span class="sxs-lookup"><span data-stu-id="8da1b-139">Simulation Algorithms</span></span> ###

<span data-ttu-id="8da1b-140">量程模拟算法将 Hamiltonian 的给定描述转换为一系列基元量子入口，作为一个整体，这是一项 Hamiltonian 的大致时间演变。</span><span class="sxs-lookup"><span data-stu-id="8da1b-140">A quantum simulation algorithm converts a given description of a Hamiltonian into a sequence of primitive quantum gates that, as a whole, approximate time-evolution by said Hamiltonian.</span></span>

<span data-ttu-id="8da1b-141">在 Hamiltonian 分解为 Hermitian 部分求和的特殊情况下，Trotter-Suzuki 分解是一个特别简单且直观的算法，用于模拟将分解为 Hamiltonians 组件的总和的 Hermitian。</span><span class="sxs-lookup"><span data-stu-id="8da1b-141">In the special case where the Hamiltonian decomposes into a sum of Hermitian parts, the Trotter-Suzuki decomposition is a particularly simple and intuitive algorithm for simulating Hamiltonians that decompose into a sum of Hermitian components.</span></span> <span data-ttu-id="8da1b-142">例如，此系列的第一个订单集成器约为 $ $ \begin{align} U （t） & = \left （e ^ {-iH\_0 t/r} e ^ {-iH\_1 t/r} \cdots e ^ {-iH\_{d-1} t/r} max_j \rightH\_j\\| ^ 2 t ^ 2/r），\end{align} $ $ 使用 $r d $ 条款的产品。</span><span class="sxs-lookup"><span data-stu-id="8da1b-142">For instance, a first-order integrator of this family approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / r} e^{-iH\_1 t / r} \cdots e^{-iH\_{d-1} t / r} \right)^{r} + \mathcal{O}(d^2 \max_j\\|H\_j\\|^2 t^2/r), \end{align} $$ using a product of $r d$ terms.</span></span> 

> [!TIP]
> <span data-ttu-id="8da1b-143">示例中介绍了 Trotter-Suzuki 模拟算法的应用程序。</span><span class="sxs-lookup"><span data-stu-id="8da1b-143">Applications of the Trotter-Suzuki simulation algorithm are covered in the samples.</span></span>
> <span data-ttu-id="8da1b-144">对于 Ising 模型，只使用每个目标计算机提供的内部操作，请参阅[ **SimpleIsing**示例](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-144">For the Ising model using only the intrinsic operations provided by each target machine, please see the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/blob/master/samples/simulation/ising/simple).</span></span>
> <span data-ttu-id="8da1b-145">对于使用 Trotter-Suzuki 库控件结构的 Ising 模型，请参阅[ **IsingTrotter**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-145">For the Ising model using the Trotter-Suzuki library control structure, please see the [**IsingTrotter** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/trotter-evolution).</span></span>
> <span data-ttu-id="8da1b-146">对于使用 Trotter-Suzuki 库控件结构的分子 Hydrogen，请参阅[ **H2 模拟**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-146">For molecular Hydrogen using the Trotter-Suzuki library control structure, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line).</span></span>

<span data-ttu-id="8da1b-147">在许多情况下，我们想要实现模拟算法，但并不关心其实现的详细信息。</span><span class="sxs-lookup"><span data-stu-id="8da1b-147">In many cases, we would like to implement the simulation algorithm, but are not interested in the details of its implementation.</span></span> <span data-ttu-id="8da1b-148">例如，第二顺序集成器近似于 $ $ \begin{align} U （t） & = \left （e ^ {-iH\_0 t/2r} e ^ {-iH\_1 t/2r} \cdots e ^ {-iH\_{d-1} t/2r} e ^ {-iH\_{d-1} t/2r} \cdots e ^ {-iH\_1 t/2r} e ^ {-iH\_0 t/2r} \right） ^ {r} + \mathcal{O} （d ^ 3 \ max_j\\|H\_j\\| ^ 3 t ^ 3/r ^ 2），\end{align} $ $ 使用产品 $ 2rd $ 条款。</span><span class="sxs-lookup"><span data-stu-id="8da1b-148">For instance, the second-order integrator approximates $$ \begin{align} U(t) & = \left( e^{-iH\_0 t / 2r} e^{-iH\_1 t / 2r} \cdots e^{-iH\_{d-1} t / 2r} e^{-iH\_{d-1} t / 2r}  \cdots e^{-iH\_1 t / 2r} e^{-iH\_0 t / 2r} \right)^{r} + \mathcal{O}(d^3 \max_j\\|H\_j\\|^3 t^3/r^2), \end{align} $$ using a product of $2rd$ terms.</span></span> <span data-ttu-id="8da1b-149">更大的订单会涉及更多的术语，而优化后的变量可能需要对指数的高度非常重要的排序。</span><span class="sxs-lookup"><span data-stu-id="8da1b-149">Larger orders will involve even more terms and optimized variants may require highly non-trivial orderings on the exponentials.</span></span> <span data-ttu-id="8da1b-150">其他高级算法还可能涉及在中间步骤中使用 ancilla qubits。</span><span class="sxs-lookup"><span data-stu-id="8da1b-150">Other advanced algorithms may also involve the use of ancilla qubits in intermediate steps.</span></span> <span data-ttu-id="8da1b-151">因此，我们将 canon 中的模拟算法打包为用户定义的类型</span><span class="sxs-lookup"><span data-stu-id="8da1b-151">Thus we package simulation algorithms in the canon as the user-defined type</span></span>

```qsharp
newtype SimulationAlgorithm = ((Double, EvolutionGenerator, Qubit[]) => Unit is Adj + Ctl);
```

<span data-ttu-id="8da1b-152">第一个参数 `Double` 是模拟时间，第二个参数 `EvolutionGenerator`（在[数据结构](xref:microsoft.quantum.libraries.data-structures)的 Dynamical 生成器表示形式部分中），它是一种与时间无关的 Hamiltonian 的传统说明，其中包含有关 Hamiltonian 中每个术语如何由量程线路模拟的说明。</span><span class="sxs-lookup"><span data-stu-id="8da1b-152">The first parameter `Double` is the time of simulation, the second parameter `EvolutionGenerator`, covered in the Dynamical Generator Representation section of [data-structures](xref:microsoft.quantum.libraries.data-structures), is a classical description of a time-independent Hamiltonian packaged with instructions on how each term in the Hamiltonian may be simulated by a quantum circuit.</span></span> <span data-ttu-id="8da1b-153">此形式的类型近似于第三个参数 `Qubit[]`的单一操作 $e ^ {iHt} $，该参数是存储模拟系统的量程状态的寄存器。</span><span class="sxs-lookup"><span data-stu-id="8da1b-153">Types of this form approximate the unitary operation $e^{-iHt}$ on the third parameter `Qubit[]`, which is the register storing the quantum state of the simulated system.</span></span> <span data-ttu-id="8da1b-154">与时间相关的情况类似，我们使用 `EvolutionSchedule` 类型来定义用户定义的类型，该类型是依赖于时间的 Hamiltonian 的传统说明。</span><span class="sxs-lookup"><span data-stu-id="8da1b-154">Similarly for the time-dependent case, we define a user-defined type with an `EvolutionSchedule` type instead, which is a classical description of a time-dependent Hamiltonian.</span></span>

```qsharp
newtype TimeDependentSimulationAlgorithm = ((Double, EvolutionSchedule, Qubit[]) => Unit : Adjoint, Controlled);
```

<span data-ttu-id="8da1b-155">例如，可以使用以下 canon 函数调用 Trotter-Suzuki 分解，其中的参数 `trotterStepSize` 修改每个指数中的模拟持续时间，并按所需的集成器顺序 `trotterOrder`。</span><span class="sxs-lookup"><span data-stu-id="8da1b-155">As an example, the Trotter-Suzuki decomposition may be called using the following canon functions, with parameters `trotterStepSize` modifying the duration of simulation in each exponential, and `trotterOrder` for the order of the desired integrator.</span></span>

```qsharp
function TrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : SimulationAlgorithm {
    ...
}
function TimeDependentTrotterSimulationAlgorithm(
    trotterStepSize: Double, 
    trotterOrder: Int) 
    : TimeDependentSimulationAlgorithm {
    ...
}
```

> [!TIP]
> <span data-ttu-id="8da1b-156">示例中介绍了模拟库的应用程序。</span><span class="sxs-lookup"><span data-stu-id="8da1b-156">Applications of the simulation library are covered in the samples.</span></span> <span data-ttu-id="8da1b-157">有关使用 `SimulationAlgorithm`的 Ising 模型中的阶段估算，请参阅[ **IsingPhaseEstimation**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-157">For phase estimation in the Ising model using `SimulationAlgorithm`, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>
> <span data-ttu-id="8da1b-158">有关使用 `TimeDependentSimulationAlgorithm`在 Ising 模型中准备 adiabatic 状态，请参阅[ **AdiabaticIsing**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-158">For adiabatic state preparation in the Ising model using `TimeDependentSimulationAlgorithm`, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>


### <a name="adiabatic-state-preparation--phase-estimation"></a><span data-ttu-id="8da1b-159">Adiabatic 状态准备 & 阶段估计</span><span class="sxs-lookup"><span data-stu-id="8da1b-159">Adiabatic State Preparation & Phase Estimation</span></span> ###

<span data-ttu-id="8da1b-160">Hamiltonian 模拟的一个常见应用是 adiabatic 状态准备。</span><span class="sxs-lookup"><span data-stu-id="8da1b-160">One common application of Hamiltonian simulation is adiabatic state preparation.</span></span> <span data-ttu-id="8da1b-161">此处提供了两个 Hamiltonians $H 的两个\_{\text{start}} $ 和 $H\_{\text{end}} $）和一个量程状态 $ \ket{\psi （0）} $，它是启动 Hamiltonian $H\_{\text{start}} $ 的基本状态。</span><span class="sxs-lookup"><span data-stu-id="8da1b-161">Here, one is provided with two Hamiltonians $H\_{\text{start}}$ and $H\_{\text{end}}$, and a quantum state $\ket{\psi(0)}$ that is a ground state of the start Hamiltonian $H\_{\text{start}}$.</span></span> <span data-ttu-id="8da1b-162">通常情况下，会选择 $H\_{\text{start}} $，以便可以从计算基础状态 $ \ket{0\cdots 0} $ 轻松准备 $ \ket{\psi （0）} $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-162">Typically, $H\_{\text{start}}$ is chosen such that $\ket{\psi(0)}$ is easy to prepare from a computational basis state $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="8da1b-163">通过在依赖于时间的模拟问题中将这些 Hamiltonians 内插到非常缓慢的情况下，最终 Hamiltonian $H 的基本状态下，可能会有很高的概率\_{\text{end}} $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-163">By interpolating between these Hamiltonians in the time-dependent simulation problem sufficiently slowly, it is possible to end up, with high probability, in a ground state of the final Hamiltonian $H\_{\text{end}}$.</span></span> <span data-ttu-id="8da1b-164">尽管准备好的方法是 Hamiltonian 的基本状态，但通过在依赖于时间的 Hamiltonian 模拟算法上调用作为子例程的其他方法（如 variational 量程），eigensolver 是可能的。</span><span class="sxs-lookup"><span data-stu-id="8da1b-164">Though preparing good approximations to Hamiltonian ground states could proceed in this manner by calling upon on time-dependent Hamiltonian simulation algorithms as a subroutine, other conceptually different approaches such as the variational quantum eigensolver are possible.</span></span>

<span data-ttu-id="8da1b-165">然而，在量子化学中普遍的另一个应用程序正在估算 Hamiltonians 的地面状态能量，表示化学反应的中间步骤。</span><span class="sxs-lookup"><span data-stu-id="8da1b-165">Yet another application ubiquitous in quantum chemistry is estimating the ground state energy of Hamiltonians representing the intermediate steps of chemical reaction.</span></span> <span data-ttu-id="8da1b-166">例如，这种方案可以依赖 adiabatic 状态准备来创建地面状态，然后将与时间无关的 Hamiltonian 模拟合并为阶段估算特征中的子例程，以利用一些有限的错误来提取此能量，并成功的概率。</span><span class="sxs-lookup"><span data-stu-id="8da1b-166">Such a scheme could, for instance, rely on adiabatic state preparation to create the ground state, and then incorporate time-independent Hamiltonian simulation as a subroutine in phase estimation characterization to extract this energy with some finite error and probability of success.</span></span> 

<span data-ttu-id="8da1b-167">将模拟算法抽象为用户定义类型 `SimulationAlgorithm` 和 `TimeDependentSimulationAlgorithm` 使我们能够方便地将其功能合并到更复杂的量程算法中。</span><span class="sxs-lookup"><span data-stu-id="8da1b-167">Abstracting simulation algorithms as the user-defined types `SimulationAlgorithm` and `TimeDependentSimulationAlgorithm` allow us to conveniently incorporate their functionality into more sophisticated quantum algorithms.</span></span> <span data-ttu-id="8da1b-168">这激发我们为这些常用的子例程执行相同操作。</span><span class="sxs-lookup"><span data-stu-id="8da1b-168">This motivates us to do the same for these commonly used subroutines.</span></span>

<span data-ttu-id="8da1b-169">因此，我们定义了便捷函数</span><span class="sxs-lookup"><span data-stu-id="8da1b-169">Thus we define the convenient function</span></span>

```qsharp
function InterpolatedEvolution(
        interpolationTime: Double, 
        evolutionGeneratorStart: EvolutionGenerator,
        evolutionGeneratorEnd: EvolutionGenerator,
        timeDependentSimulationAlgorithm: TimeDependentSimulationAlgorithm)
        : (Qubit[] => Unit is Adj + Ctl) {
        ...
}
 
```

<span data-ttu-id="8da1b-170">这会返回单一操作，该操作将实现 adiabatic 状态准备的所有步骤。</span><span class="sxs-lookup"><span data-stu-id="8da1b-170">This returns a unitary operation that implements all steps of adiabatic state preparation.</span></span> <span data-ttu-id="8da1b-171">第一个参数 `interpolatedTime` 定义一个时间，在该时间之后，我们将在第二个参数 `evolutionGeneratorStart` 和第三个参数 `evolutionGeneratorEnd`描述的结束 Hamiltonian 之间以线性方式进行插入。</span><span class="sxs-lookup"><span data-stu-id="8da1b-171">The first parameter `interpolatedTime` defines the time over which we linearly interpolate between the start Hamiltonian described by the second parameter `evolutionGeneratorStart` and the end Hamiltonian described by the third parameter `evolutionGeneratorEnd`.</span></span> <span data-ttu-id="8da1b-172">第四个参数 `timeDependentSimulationAlgorithm` 是一种选择模拟算法的位置。</span><span class="sxs-lookup"><span data-stu-id="8da1b-172">The fourth parameter `timeDependentSimulationAlgorithm` is where one makes the choice of simulation algorithm.</span></span> <span data-ttu-id="8da1b-173">请注意，如果 `interpolatedTime` 的时间足够长，则在整个时间依赖模拟的整个持续时间内，最初的状态将保持 Hamiltonian 的瞬时地面状态，从而结束 Hamiltonian 结束。</span><span class="sxs-lookup"><span data-stu-id="8da1b-173">Note that if `interpolatedTime` is long enough, an initial ground state remains an instantaneous ground state of the Hamiltonian over the entire duration of time-dependent simulation, and thus ends in the ground state of the end Hamiltonian.</span></span>

<span data-ttu-id="8da1b-174">我们还定义了一个帮助操作，该操作会自动执行典型的量程化学试验的所有步骤。</span><span class="sxs-lookup"><span data-stu-id="8da1b-174">We also define a helpful operation that automatically performs all steps of a typical quantum chemistry experiment.</span></span> <span data-ttu-id="8da1b-175">例如，我们提供了以下内容，它将返回 adiabatic 状态准备所产生状态的能源估算：</span><span class="sxs-lookup"><span data-stu-id="8da1b-175">For instance we have the following, which returns an energy estimate of the state produced by adiabatic state preparation:</span></span>

```qsharp
operation AdiabaticStateEnergyEstimate( 
    nQubits : Int, 
    statePrepUnitary: (Qubit[] => Unit),
    adiabaticUnitary: (Qubit[] => Unit),
    qpeUnitary: (Qubit[] => Unit is Adj + Ctl),
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) 
    : Double {
...
}
```

<span data-ttu-id="8da1b-176">`nQubits` 是用于对初始量程状态进行编码的 qubits 的数目。</span><span class="sxs-lookup"><span data-stu-id="8da1b-176">`nQubits` is the number of qubits used to encode the initial quantum state.</span></span> <span data-ttu-id="8da1b-177">`statePrepUnitary` 从计算基础 $ \ket{0\cdots 0} $ 准备开始状态。</span><span class="sxs-lookup"><span data-stu-id="8da1b-177">`statePrepUnitary` prepares the start state from the computational basis $\ket{0\cdots 0}$.</span></span> <span data-ttu-id="8da1b-178">`adiabaticUnitary` 是实现 adiabatic 状态准备的单一操作，如 `InterpolatedEvolution` 函数生成的。</span><span class="sxs-lookup"><span data-stu-id="8da1b-178">`adiabaticUnitary` is the unitary operation that implements adiabatic state preparation, such as produced by the  `InterpolatedEvolution` function.</span></span> <span data-ttu-id="8da1b-179">`qpeUnitary` 是用于对生成的量程状态执行阶段估算的单一操作。</span><span class="sxs-lookup"><span data-stu-id="8da1b-179">`qpeUnitary` is the unitary operation that is used to perform phase estimation on the resulting quantum state.</span></span> <span data-ttu-id="8da1b-180">`phaseEstAlgorithm` 是我们选择的阶段估算算法。</span><span class="sxs-lookup"><span data-stu-id="8da1b-180">`phaseEstAlgorithm` is our choice of phase estimation algorithm.</span></span>

> [!TIP]
> <span data-ttu-id="8da1b-181">示例中介绍了 adiabatic 状态准备的应用程序。</span><span class="sxs-lookup"><span data-stu-id="8da1b-181">Applications of adiabatic state preparation are covered in the samples.</span></span> <span data-ttu-id="8da1b-182">对于 Ising 模型，使用手动实现 adiabatic 状态准备与使用 `AdiabaticEvolution` 函数，请参阅[ **AdiabaticIsing**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-182">For the Ising model using a manual implementation of adiabatic state preparation versus using the `AdiabaticEvolution` function, please see the [**AdiabaticIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/adiabatic).</span></span>
> <span data-ttu-id="8da1b-183">有关 Ising 模型中的阶段估算和 adiabatic 状态准备，请参阅[ **IsingPhaseEstimation**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation)。</span><span class="sxs-lookup"><span data-stu-id="8da1b-183">For phase estimation and adiabatic state preparation in the Ising model, please see the [**IsingPhaseEstimation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/phase-estimation).</span></span>

> [!TIP]
> <span data-ttu-id="8da1b-184">[分子 Hydrogen 的模拟](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)是一个有趣且简单的示例。</span><span class="sxs-lookup"><span data-stu-id="8da1b-184">The [simulation of molecular Hydrogen](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line) is an interesting and brief sample.</span></span> <span data-ttu-id="8da1b-185">[O'Malley et](https://arxiv.org/abs/1512.06860)中报告的模型和实验性结果。</span><span class="sxs-lookup"><span data-stu-id="8da1b-185">The model and experimental results reported in [O'Malley et. al.](https://arxiv.org/abs/1512.06860)</span></span> <span data-ttu-id="8da1b-186">仅要求使用 Pauli 矩阵，并采用 "$ \hat H = g\_" 形式 {0}I\_0 I\_1 + g\_1 {Z\_{Z\_0} {Z\_1} + g\_4 {Y\_0} {Y\_1} + g\_5 {X\_0} {X\_1} $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-186">only requires Pauli matrices and takes the form $\hat H = g\_{0}I\_0I\_1+g\_1{Z\_0}+g\_2{Z\_1}+g\_3{Z\_0}{Z\_1}+g\_4{Y\_0}{Y\_1}+g\_5{X\_0}{X\_1}$.</span></span> <span data-ttu-id="8da1b-187">这是一个有效的 Hamiltonian，只需要2个 qubits，在这种情况下，将根据两个 Hydrogen 原子之间的距离 $R $ 计算 $g $ 的常量。</span><span class="sxs-lookup"><span data-stu-id="8da1b-187">This is an effective Hamiltonian only requiring only 2 qubits, where the constants $g$ are computed from the distance $R$ between the two Hydrogen atoms.</span></span> <span data-ttu-id="8da1b-188">使用 canon 函数，Paulis 转换为 unitaries，然后使用 Trotter-Suzuki 分解在短时间段内演变。</span><span class="sxs-lookup"><span data-stu-id="8da1b-188">Using canon functions, the Paulis are converted to unitaries and then evolved over short periods of time using the Trotter-Suzuki decomposition.</span></span> <span data-ttu-id="8da1b-189">可以在不使用 adiabatic 状态准备的情况下创建 $H _2 $ 地面状态的良好近似值，因此，可以通过利用 canon 中的阶段估算直接找到地面状态。</span><span class="sxs-lookup"><span data-stu-id="8da1b-189">A good approximation to the $H_2$ ground state can be created without using adiabatic state preparation, and so the ground state energy may be found directly by utilizing phase estimation from the canon.</span></span>

## <a name="shors-algorithm"></a><span data-ttu-id="8da1b-190">秀尔算法</span><span class="sxs-lookup"><span data-stu-id="8da1b-190">Shor's Algorithm</span></span> ##
<span data-ttu-id="8da1b-191">选定的算法仍是量程计算中最重要的开发，因为它显示了量程计算机可以用于解决重要的当前经典棘手问题。</span><span class="sxs-lookup"><span data-stu-id="8da1b-191">Shor's algorithm remains one of the most significant developments in quantum computing because it showed that quantum computers could be used to solve important, currently classically intractable problems.</span></span>
<span data-ttu-id="8da1b-192">选定的算法提供了一种使用量程计算机（称为 "*分解*" 的问题）对较大数字进行因式分解的快速方法。</span><span class="sxs-lookup"><span data-stu-id="8da1b-192">Shor's algorithm provides a fast way to factor large numbers using a quantum computer, a problem called *factoring*.</span></span>
<span data-ttu-id="8da1b-193">许多 cryptosystems 的安全是基于不存在任何快速算法以进行分解的假设。</span><span class="sxs-lookup"><span data-stu-id="8da1b-193">The security of many present-day cryptosystems is based on the assumption that no fast algorithm exists for factoring.</span></span>
<span data-ttu-id="8da1b-194">因此，选定的算法对我们在一个量程后世界中的安全性的看法产生了深远的影响。</span><span class="sxs-lookup"><span data-stu-id="8da1b-194">Thus Shor's algorithm has had a profound impact on how we think about security in a post-quantum world.</span></span>

<span data-ttu-id="8da1b-195">选定的算法可以看作是一种混合算法。</span><span class="sxs-lookup"><span data-stu-id="8da1b-195">Shor's algorithm can be thought of as a hybrid algorithm.</span></span>
<span data-ttu-id="8da1b-196">量程计算机用于执行称为 "期间查找" 的计算硬任务。</span><span class="sxs-lookup"><span data-stu-id="8da1b-196">The quantum computer is used to perform a computationally hard task known as period finding.</span></span>
<span data-ttu-id="8da1b-197">然后，将经典的结果处理为估算系数。</span><span class="sxs-lookup"><span data-stu-id="8da1b-197">The results from period finding are then classically processed to estimate the factors.</span></span>
<span data-ttu-id="8da1b-198">下面是两个步骤。</span><span class="sxs-lookup"><span data-stu-id="8da1b-198">We review these two steps below.</span></span>

### <a name="period-finding"></a><span data-ttu-id="8da1b-199">期间查找</span><span class="sxs-lookup"><span data-stu-id="8da1b-199">Period Finding</span></span> ###

<span data-ttu-id="8da1b-200">了解到量程傅立叶转换和阶段估算工作（请参阅[量程算法](xref:microsoft.quantum.libraries.standard.algorithms)）后，我们可以使用这些工具解决称为*时间段查找*的经典硬计算问题。</span><span class="sxs-lookup"><span data-stu-id="8da1b-200">Having seen how the quantum Fourier transform and phase estimation work (see [Quantum algorithms](xref:microsoft.quantum.libraries.standard.algorithms)), we can use these tools to solve a classically hard computational problem called *period finding*.</span></span>  <span data-ttu-id="8da1b-201">在下一部分中，我们将了解如何应用时间段查找以进行分解。</span><span class="sxs-lookup"><span data-stu-id="8da1b-201">In the next section, we will see how to apply period finding to factoring.</span></span>

<span data-ttu-id="8da1b-202">给定两个整数 $a $ 和 $N $，其中 $a < N $，句点的目标（也称为顺序查找）是查找 $r $ $a $ $N $ 的_顺序_$r $ $a $，其中 $ 被定义为最少的正整数，^ r \equiv 1 \text{Mod} N $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-202">Given two integers $a$ and $N$, where $a<N$, the goal of period finding, also called order finding, is to find the _order_ $r$ of $a$ modulo $N$, where $r$ is defined to be the least positive integer such that $a^r \equiv 1 \text{ mod } N$.</span></span>  

<span data-ttu-id="8da1b-203">若要查找使用量程计算机的顺序，可以使用应用于以下单一运算符的阶段估算算法，$U _a $： $ $ U_a \ket{x} \equiv \ket{（ax） \text{mod} N}。 $ $ $U _a $ 的本征向量为 integer $s $ 和 $ 0 \ leq s \leq r-$1，$ $ \ket{x_s} \equiv 1/\sqrt{r} \sum\_{k = 0} ^ {r}} \frac{-2\pi ^ \ket{a {mod} N}，$ $ 是 $U _a $ 的_k\text_ 。</span><span class="sxs-lookup"><span data-stu-id="8da1b-203">To find the order using a quantum computer, we can use the phase estimation algorithm applied to the following unitary operator $U_a$: $$ U_a\ket{x} \equiv \ket{(ax)\text{ mod }N} .$$ The eigenvectors of $U_a$ are for integer $s$ and $0\leq s \leq r - 1$, $$\ket{x_s} \equiv 1 / \sqrt{r} \sum\_{k=0}^{r-1} e^{\frac{-2\pi i sk}{r}} \ket{a^k\text{ mod }N},$$ are _eigenstates_ of $U_a$.</span></span>
<span data-ttu-id="8da1b-204">$U _a $ 的本征值是 $ $ U\_\ket{x\_s} = e ^ {2 \ pi i s/r} \ket{x\_s}。</span><span class="sxs-lookup"><span data-stu-id="8da1b-204">The eigenvalues of $U_a$ are $$ U\_a \ket{x\_s} = e^{2\pi i s / r} \ket{x\_s} .</span></span> $$

<span data-ttu-id="8da1b-205">这样，阶段估计就会输出本征值 $e ^ {2 \ pi i s/r} $，其中 $r $ 可以通过 $s/r $ 中的[连续分数](https://en.wikipedia.org/wiki/Continued_fraction)有效地进行学习。</span><span class="sxs-lookup"><span data-stu-id="8da1b-205">Phase estimation thus outputs the eigenvalues $e^{2\pi i s / r}$ from which $r$ can be learned efficiently using [continued fractions](https://en.wikipedia.org/wiki/Continued_fraction) from $s / r$.</span></span>

<span data-ttu-id="8da1b-206">量程期间查找的线路关系图为：</span><span class="sxs-lookup"><span data-stu-id="8da1b-206">The circuit diagram for quantum period finding is:</span></span>

![](./../../media/QPE.svg)

<span data-ttu-id="8da1b-207">此处，$ 2n $ qubits 初始化为 $ \ket{0}$，$n $ qubits 初始化为 $ \ket{1}$。</span><span class="sxs-lookup"><span data-stu-id="8da1b-207">Here $2n$ qubits are initialized to $\ket{0}$ and $n$ qubits are initialized to $\ket{1}$.</span></span>
<span data-ttu-id="8da1b-208">读者可能会想知道，将 eigenstates 的量程寄存器初始化为 $ \ket{1}$ 的原因。</span><span class="sxs-lookup"><span data-stu-id="8da1b-208">The reader again may wonder why the quantum register to hold the eigenstates is initialized to $\ket{1}$.</span></span>
<span data-ttu-id="8da1b-209">如果事先不知道订单 $r $，我们实际上无法直接准备 $ \ket{x_s} $ 状态。</span><span class="sxs-lookup"><span data-stu-id="8da1b-209">As one does not know the order $r$ in advance, we cannot actually prepare $\ket{x_s}$ states directly.</span></span>
<span data-ttu-id="8da1b-210">幸好，事实证明，$ 1/\ sqrt {r} \sum\_{s = 0} ^ {r-1} \ket{x\_s} = \ket{1}$。</span><span class="sxs-lookup"><span data-stu-id="8da1b-210">Luckily, it turns out that $1/\sqrt{r} \sum\_{s=0}^{r-1} \ket{x\_s} = \ket{1}$.</span></span>
<span data-ttu-id="8da1b-211">我们不需要实际准备 $ \ket{x} $！</span><span class="sxs-lookup"><span data-stu-id="8da1b-211">We don't need to actually prepare $\ket{x}$!</span></span>
<span data-ttu-id="8da1b-212">我们只需在状态 $ \ket{1}$ 中准备 $n $ qubits 的量程寄存器。</span><span class="sxs-lookup"><span data-stu-id="8da1b-212">We can just prepare a quantum register of $n$ qubits in state $\ket{1}$.</span></span> 

<span data-ttu-id="8da1b-213">线路包含 QFT 和多个受控入口。</span><span class="sxs-lookup"><span data-stu-id="8da1b-213">The circuit contains the QFT and several controlled gates.</span></span>
<span data-ttu-id="8da1b-214">[之前](xref:microsoft.quantum.libraries.standard.algorithms)已描述 QFT 入口。</span><span class="sxs-lookup"><span data-stu-id="8da1b-214">The QFT gate has been described [previously](xref:microsoft.quantum.libraries.standard.algorithms).</span></span>
<span data-ttu-id="8da1b-215">如果 control qubit 是 $ \ket{1}$，则受控 $U _a $ \ket{x} $ 到 $ \ket{（ax） \text{mod} N} $，否则将 $ \ket{x} $ 映射到 $ \ket{x} $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-215">The controlled-$U_a$ gate maps $\ket{x}$ to $\ket{(ax)\text{ mod } N}$ if the control qubit is $\ket{1}$, and maps $\ket{x}$ to $\ket{x}$ otherwise.</span></span>

<span data-ttu-id="8da1b-216">若要实现 $ （a ^ nx） \text{mod} N $，我们只需应用受控-$U _ {a ^ N} $，我们计算 $a ^ N \text{mod} N $ 经典，以插入量程线路。</span><span class="sxs-lookup"><span data-stu-id="8da1b-216">To achieve $(a^nx)\text{ mod } N$,  we can simply apply controlled-$U_{a^n}$, where we calculate $a^n \text{ mod } N$ classically to plug into the quantum circuit.</span></span>  
<span data-ttu-id="8da1b-217">[量程算法文档](./algorithms.md#arithmetic)中介绍了实现这种模块化算法的线路，具体而言，我们需要使用模块求幂线路来实现受控-$U\_{a ^ i} $ 操作。</span><span class="sxs-lookup"><span data-stu-id="8da1b-217">The circuits to achieve such modular arithmetic have been described in the [quantum arithmetic documentation](./algorithms.md#arithmetic), specifically we require a modular exponentiation circuit to implement the controlled-$U\_{a^i}$ operations.</span></span>

<span data-ttu-id="8da1b-218">尽管上面的线路对应于[量程阶段估算](xref:microsoft.quantum.characterization.quantumphaseestimation)，并显式启用了订单查找，但我们可以减少所需的 qubits 数量。</span><span class="sxs-lookup"><span data-stu-id="8da1b-218">While the circuit above corresponds to [Quantum Phase Estimation](xref:microsoft.quantum.characterization.quantumphaseestimation) and explicitly enables order finding, we can reduce the number of qubits required.</span></span> <span data-ttu-id="8da1b-219">我们可以按照[arXiv： quant/0205095V3 第8页](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8)中所述的顺序查找 Beauregard 的方法，或使用中提供的一个阶段估算例程。</span><span class="sxs-lookup"><span data-stu-id="8da1b-219">We can either follow Beauregard's method for order finding as described [on Page 8 of arXiv:quant-ph/0205095v3](https://arxiv.org/pdf/quant-ph/0205095v3.pdf#page=8), or use one of the phase estimation routines available in Microsoft.Quantum.Canon.</span></span> <span data-ttu-id="8da1b-220">例如，[强健的阶段估算](xref:microsoft.quantum.characterization.robustphaseestimation)还使用一个额外的 qubit。</span><span class="sxs-lookup"><span data-stu-id="8da1b-220">For example, [Robust Phase Estimation](xref:microsoft.quantum.characterization.robustphaseestimation) also uses one extra qubit.</span></span>
 
### <a name="factoring"></a><span data-ttu-id="8da1b-221">分解</span><span class="sxs-lookup"><span data-stu-id="8da1b-221">Factoring</span></span> ###
<span data-ttu-id="8da1b-222">因式分解的目标是确定整数 $N $ 的两个质数因素，其中 $N $ 是 $n $ 位数字。</span><span class="sxs-lookup"><span data-stu-id="8da1b-222">The goal of factoring is to determine the two prime factors of integer $N$, where $N$ is an $n$-bit number.</span></span>  
<span data-ttu-id="8da1b-223">因式分解包含如下所述的步骤。</span><span class="sxs-lookup"><span data-stu-id="8da1b-223">Factoring consists of the steps described below.</span></span> <span data-ttu-id="8da1b-224">步骤分为三个部分：传统预处理例程（1-4）;用于查找 $a \text{mod} N $ （5）的顺序的量程计算例程;和一个传统的后处理例程，用于从顺序中派生出质数因素（6-9）。</span><span class="sxs-lookup"><span data-stu-id="8da1b-224">The steps are split into three parts: a classical preprocessing routine (1-4); a quantum computing routine to find the order of $a \text{ mod } N$ (5); and a classical postprocessing routine to derive the prime factors from the order (6-9).</span></span>

<span data-ttu-id="8da1b-225">传统预处理例程包含以下步骤：</span><span class="sxs-lookup"><span data-stu-id="8da1b-225">The classical preprocessing routine consists of the following steps:</span></span>
1. <span data-ttu-id="8da1b-226">如果 $N $ 为偶数，则返回质数系数 $2 $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-226">If $N$ is even, return the prime factor $2$.</span></span>
2. <span data-ttu-id="8da1b-227">如果 $p \geq1 $ $N = p ^ q $，$q \geq2 $，则返回 $p $ 的质数。</span><span class="sxs-lookup"><span data-stu-id="8da1b-227">If $N=p^q$ for $p\geq1$, $q\geq2$, return the prime factor $p$.</span></span>  <span data-ttu-id="8da1b-228">此步骤在经典执行。</span><span class="sxs-lookup"><span data-stu-id="8da1b-228">This step is performed classically.</span></span>
3. <span data-ttu-id="8da1b-229">选择一个随机数字 $a $，$1 < < N-$1。</span><span class="sxs-lookup"><span data-stu-id="8da1b-229">Choose a random number $a$ such that $1 < a < N-1$.</span></span>
4. <span data-ttu-id="8da1b-230">如果 $ \text{gcd} （a，N） > 1 $，则返回质数系数 $ \text{gcd} （a，N） $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-230">If $\text{gcd}(a,N)>1$, return the prime factor $\text{gcd}(a,N)$.</span></span> <span data-ttu-id="8da1b-231">此步骤使用 Euclid 的算法进行计算。</span><span class="sxs-lookup"><span data-stu-id="8da1b-231">This step is computed using Euclid's algorithm.</span></span>
<span data-ttu-id="8da1b-232">如果未返回任何主要因素，我们将继续执行量程例程：</span><span class="sxs-lookup"><span data-stu-id="8da1b-232">If no prime factor has been returned, we proceed to the quantum routine:</span></span>
5. <span data-ttu-id="8da1b-233">调用量子 period 查找算法来计算 $a \text{mod} N $ $r $ 的顺序。</span><span class="sxs-lookup"><span data-stu-id="8da1b-233">Call the quantum period finding algorithm to calculate the order $r$ of $a \text{ mod } N$.</span></span> <span data-ttu-id="8da1b-234">使用传统的后处理例程中的 $r $ 来确定主要因素：</span><span class="sxs-lookup"><span data-stu-id="8da1b-234">Use $r$ in the classical postprocessing routine to determine the prime factors:</span></span>
6. <span data-ttu-id="8da1b-235">如果 $r $ 是奇数，请返回到预处理步骤（3）。</span><span class="sxs-lookup"><span data-stu-id="8da1b-235">If $r$ is odd, go back to preprocessing step (3).</span></span>
7. <span data-ttu-id="8da1b-236">如果 $r $ 甚至 $a ^ {r/2} =-1 \ text {mod} N $，请返回到预处理步骤（3）。</span><span class="sxs-lookup"><span data-stu-id="8da1b-236">If $r$ is even and $a^{r/2} = -1\text{ mod }N$, go back to preprocessing step (3).</span></span>
8. <span data-ttu-id="8da1b-237">如果 $ \text{gcd} （a ^ {r/2} + 1，N） $ 是 $N $ 的非常简单的因素，则返回 $ \text{gcd} （^ {r/2} + 1，N） $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-237">If $\text{gcd}(a^{r/2}+1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}+1, N)$.</span></span>
9. <span data-ttu-id="8da1b-238">如果 $ \text{gcd} （a ^ {r/2}-1，N） $ 是 $N $ 的非常简单的因素，则返回 $ \text{gcd} （^ {r/2}-1，N） $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-238">If $\text{gcd}(a^{r/2}-1, N)$ is a non-trivial factor of $N$, return $\text{gcd}(a^{r/2}-1, N)$.</span></span>


<span data-ttu-id="8da1b-239">分解算法是概率的：它可以表明，概率至少为1的一半 $r $ 将为偶数，$a ^ {r/2} \neq-1 \text{mod} N $，因此产生了一个主要因素。</span><span class="sxs-lookup"><span data-stu-id="8da1b-239">The factoring algorithm is probabilistic: it can been shown that with probability at least one half that $r$ will be even and $a^{r/2} \neq -1 \text{ mod }N$, thus producing a prime factor.</span></span>  <span data-ttu-id="8da1b-240">（有关详细[信息](xref:microsoft.quantum.more-information)，请参阅[选定的原始纸张](https://doi.org/10.1109/SFCS.1994.365700)，或中的一个*基本量程计算*文本）。</span><span class="sxs-lookup"><span data-stu-id="8da1b-240">(See [Shor's original paper](https://doi.org/10.1109/SFCS.1994.365700) for details, or one of the *Basic quantum computing* texts in [For more information](xref:microsoft.quantum.more-information)).</span></span>
<span data-ttu-id="8da1b-241">如果未返回一个质数因素，则只需重复步骤（1）中的算法。</span><span class="sxs-lookup"><span data-stu-id="8da1b-241">If a prime factor is not returned, then we simply repeat the algorithm from step (1).</span></span>  <span data-ttu-id="8da1b-242">$N $ 次尝试后，每次尝试失败的概率最多为 $ 2 ^ {-n} $。</span><span class="sxs-lookup"><span data-stu-id="8da1b-242">After $n$ tries, the probability that every attempt has failed is at most $2^{-n}$.</span></span>
<span data-ttu-id="8da1b-243">因此，在重复该算法后，几乎可确保成功的次数较少。</span><span class="sxs-lookup"><span data-stu-id="8da1b-243">Thus after repeating the algorithm a small number of times success is virtually assured.</span></span>
