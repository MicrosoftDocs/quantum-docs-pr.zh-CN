---
title: 'Q # 标准库-特性 |Microsoft Docs'
description: 'Q # 标准库-特性'
author: QuantumWriter
uid: microsoft.quantum.libraries.characterization
ms.author: martinro@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: 1eb48da9d4ae2a730019e2707dcb2c69b998491e
ms.sourcegitcommit: 27c9bf1aae923527aa5adeaee073cb27d35c0ca1
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 12/05/2019
ms.locfileid: "74864366"
---
# <a name="quantum-characterization-and-statistics"></a><span data-ttu-id="9f52a-103">量程特性和统计信息</span><span class="sxs-lookup"><span data-stu-id="9f52a-103">Quantum Characterization and Statistics</span></span> #

<span data-ttu-id="9f52a-104">为了开发有用的量程算法，能够为操作的效果建立特征非常重要。</span><span class="sxs-lookup"><span data-stu-id="9f52a-104">It is critical to be able to characterize the effects of operations in order to develop useful quantum algorithms.</span></span>
<span data-ttu-id="9f52a-105">这是一项挑战，因为量程系统的每个度量值最多可产生一位信息。</span><span class="sxs-lookup"><span data-stu-id="9f52a-105">This is challenging because every measurement of a quantum system yields at most one bit of information.</span></span>
<span data-ttu-id="9f52a-106">若要了解 eigenvalue，只需将一个量程状态通知给多个度量值，就必须将多个度量值的结果拼接在一起，以便用户能够搜集表示这些概念所需的许多信息。</span><span class="sxs-lookup"><span data-stu-id="9f52a-106">In order to learn an eigenvalue, let alone a quantum state, the results of many measurements must be stitched together so that the user can glean the many bits of information needed to represent these concepts.</span></span>
<span data-ttu-id="9f52a-107">量程状态特别棘手，因为[无克隆定理](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem)规定，无法从状态的单一副本了解任意量程状态，因为这样做可以让你创建状态的副本。</span><span class="sxs-lookup"><span data-stu-id="9f52a-107">Quantum states are especially vexing because the [no-cloning theorem](xref:microsoft.quantum.concepts.pauli#the-no-cloning-theorem) states that there is no way to learn an arbitrary quantum state from a single copy of the state, because doing so would let you make copies of the state.</span></span>
<span data-ttu-id="9f52a-108">这种情况下，用户的量程状态模糊会反映出来，因为 Q # 不会公开，甚至不会定义量程程序*的状态。*</span><span class="sxs-lookup"><span data-stu-id="9f52a-108">This obfuscation of the quantum state from the user is reflected in the fact that Q# does not expose or even define what a state *is* to quantum programs.</span></span>
<span data-ttu-id="9f52a-109">因此，通过将操作和状态视为黑箱来实现量程的特征;这种方法与量程特征、验证和验证（QCVV）的实验操作非常常见。</span><span class="sxs-lookup"><span data-stu-id="9f52a-109">We thus approach quantum characterization by treating operations and states as black-box; this approach shares much in common with the experimental practice of quantum characterization, verification and validation (QCVV).</span></span>

<span data-ttu-id="9f52a-110">特性与前面讨论的其他许多库不同。</span><span class="sxs-lookup"><span data-stu-id="9f52a-110">Characterization is distinct from many of the other libraries discussed previously.</span></span>
<span data-ttu-id="9f52a-111">此处的目标是更少了解有关系统的传统信息，而不是对状态向量执行单一转换。</span><span class="sxs-lookup"><span data-stu-id="9f52a-111">The aim here is less to learn classical information about the system, rather than to perform a unitary transformation on a state vector.</span></span>
<span data-ttu-id="9f52a-112">因此，这些库必须同时进行传统和量程信息处理。</span><span class="sxs-lookup"><span data-stu-id="9f52a-112">These libraries must therefore blend both classical and quantum information processing.</span></span>


## <a name="iterative-phase-estimation"></a><span data-ttu-id="9f52a-113">迭代阶段估算</span><span class="sxs-lookup"><span data-stu-id="9f52a-113">Iterative Phase Estimation</span></span> ##

<span data-ttu-id="9f52a-114">根据量程特征来查看量程编程，这一建议可替代量程阶段估算。</span><span class="sxs-lookup"><span data-stu-id="9f52a-114">Viewing quantum programming in terms of quantum characterization suggests a useful alternative to quantum phase estimation.</span></span>
<span data-ttu-id="9f52a-115">也就是说，我们可以查看阶段估算，而不是准备 $n $-qubit register *，使其*包含阶段的二进制表示形式（如在量程阶段估算中）。</span><span class="sxs-lookup"><span data-stu-id="9f52a-115">That is, instead of preparing an $n$-qubit register to contain a binary representation of the phase as in quantum phase estimation, we can view phase estimation as the process by which a *classical* agent learns properties of a quantum system through measurements.</span></span>
<span data-ttu-id="9f52a-116">在量程情况下，我们将使用相位 kickback 将黑色方框操作的应用程序转变为一个未知角度来旋转，但会测量 ancilla qubit，这是我们在每一步之后的每个步骤。</span><span class="sxs-lookup"><span data-stu-id="9f52a-116">We proceed as in the quantum case by using phase kickback to turn applications of a black-box operation into rotations by an unknown angle, but will measure the ancilla qubit that we rotate at each step immediately following the rotation.</span></span>
<span data-ttu-id="9f52a-117">这样做的优点是，我们只需要一个额外的 qubit 来执行量程情况下所述的阶段 kickback，因为我们然后以迭代方式从每个步骤的测量结果中学习阶段。</span><span class="sxs-lookup"><span data-stu-id="9f52a-117">This has the advantage that we only require a single additional qubit to perform the phase kickback described in the quantum case, as we then learn the phase from the measurement results at each step in an iterative fashion.</span></span>  
<span data-ttu-id="9f52a-118">以下建议的每个方法都使用不同的策略来设计试验，并使用不同的数据处理方法来了解这一阶段。</span><span class="sxs-lookup"><span data-stu-id="9f52a-118">Each of the methods proposed below uses a different strategy for designing experiments and different data processing methods to learn the phase.</span></span>  <span data-ttu-id="9f52a-119">它们各自具有独特的优势，包括严格的错误界限、合并先前信息的能力、容忍错误或在内存 limitted 传统计算机上运行。</span><span class="sxs-lookup"><span data-stu-id="9f52a-119">They each have unique advantage ranging from having rigorous error bounds, to the abilities to incorporate prior information, tolerate errors or run on memory limitted classical computers.</span></span>

<span data-ttu-id="9f52a-120">在讨论迭代阶段估计时，我们会将一个单一 $U $ 指定为一个黑色的操作。</span><span class="sxs-lookup"><span data-stu-id="9f52a-120">In discussing iterative phase estimation, we will consider a unitary $U$ given as a black-box operation.</span></span>
<span data-ttu-id="9f52a-121">如 "[数据结构](xref:microsoft.quantum.libraries.data-structures)中的 oracles" 一节中所述，Q # canon 按 <xref:microsoft.quantum.oracles.discreteoracle> 用户定义类型对 `((Int, Qubit[]) => Unit : Adjoint, Controlled)`的元组类型定义的操作进行建模。</span><span class="sxs-lookup"><span data-stu-id="9f52a-121">As described in the section on oracles in [data structures](xref:microsoft.quantum.libraries.data-structures), the Q# canon models such operations by the <xref:microsoft.quantum.oracles.discreteoracle> user-defined type, defined by the tuple type `((Int, Qubit[]) => Unit : Adjoint, Controlled)`.</span></span>
<span data-ttu-id="9f52a-122">具体而言，如果 `U : DiscreteOracle`，则 `U(m)` 实现 `m : Int`$U ^ m $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-122">Concretely, if `U : DiscreteOracle`, then `U(m)` implements $U^m$ for `m : Int`.</span></span>

<span data-ttu-id="9f52a-123">使用此定义时，每个迭代阶段估计步骤会在 $ \ket{+} $ 状态中准备一个辅助 qubit，并将其假定为 $U [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) （m） $，即 $U （m） \ket{\phi} = e ^ {im\phi} \ 票证 {\ phi} $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-123">With this definition in place, each step of iterative phase estimation proceeds by preparing an auxillary qubit in the $\ket{+}$ state along with the initial state $\ket{\phi}$ that we assume is an [eigenvector](xref:microsoft.quantum.concepts.matrix-advanced) of $U(m)$, i.e. $U(m)\ket{\phi}= e^{im\phi}\ket{\phi}$.</span></span>  
<span data-ttu-id="9f52a-124">然后，将使用 `U(m)` 的受控应用程序来准备状态 $ \left （R\_1 （m \phi） \ket{+} \right） \ket{\phi} $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-124">A controlled application of `U(m)` is then used which prepares the state $\left(R\_1(m \phi) \ket{+}\right)\ket{\phi}$.</span></span>
<span data-ttu-id="9f52a-125">正如在量程情况下，受影响的 oracle `U(m)` 的受控应用程序的影响与在 $ \ket{+} $ 上将 $R _1 $ 应用于未知阶段的效果完全相同，因此我们可以更简单的方式描述 $U $ 的影响。</span><span class="sxs-lookup"><span data-stu-id="9f52a-125">As in the quantum case, the effect of a controlled application of the oracle `U(m)` is precisely the same as the effect of applying $R_1$ for the unknown phase on $\ket{+}$, such that we can describe the effects of $U$ in this simpler fashion.</span></span>
<span data-ttu-id="9f52a-126">然后，该算法通过应用 $R _1 （-m\theta） $ 以获取状态 $ \ket{\psi} = \left （R\_1 （m [\phi-\theta]） \ket{+} \right） \ket{\phi} $ $ 来旋转控件 qubit。</span><span class="sxs-lookup"><span data-stu-id="9f52a-126">Optionally, the algorithm then rotates the control qubit by applying $R_1(-m\theta)$ to obtain a state $\ket{\psi}=\left(R\_1(m [\phi-\theta]) \ket{+}\right)\ket{\phi}$$.</span></span>
<span data-ttu-id="9f52a-127">然后，将辅助 qubit 用作 `U(m)` 的控件，并按 $X $ basis 度量，以获取单个传统 `Result`。</span><span class="sxs-lookup"><span data-stu-id="9f52a-127">The auxillary qubit used as a control for `U(m)` is then measured in the $X$ basis to obtain a single classical `Result`.</span></span>

<span data-ttu-id="9f52a-128">此时，从通过迭代阶段估算获取的 `Result` 值重建阶段是一种传统的统计推理问题。</span><span class="sxs-lookup"><span data-stu-id="9f52a-128">At this point, reconstructing the phase from the `Result` values obtained through iterative phase estimation is a classical statistical inference problem.</span></span>
<span data-ttu-id="9f52a-129">如果查找 $m $ 这一值可最大化获取的信息，则在给定固定推理方法的情况下，只是统计信息中的一个问题。</span><span class="sxs-lookup"><span data-stu-id="9f52a-129">Finding the value of $m$ that maximizes the information gained, given a fixed inference method, is simply a problem in statistics.</span></span>
<span data-ttu-id="9f52a-130">我们将在 Bayesian 参数估算形式中简要介绍理论级别的迭代阶段估算，然后再继续介绍 Q # canon 中提供的用于解决这一传统推理问题的统计算法。</span><span class="sxs-lookup"><span data-stu-id="9f52a-130">We emphasize this by briefly describing iterative phase estimation at a theoretical level in the Bayesian parameter estimation formalism before proceeding to describe the statistical algorithms provided in the Q# canon for solving this classical inference problem.</span></span>

### <a name="iterative-phase-estimation-without-eigenstates"></a><span data-ttu-id="9f52a-131">不 Eigenstates 的迭代阶段估算</span><span class="sxs-lookup"><span data-stu-id="9f52a-131">Iterative Phase Estimation Without Eigenstates</span></span> ###

<span data-ttu-id="9f52a-132">如果提供的是不是 eigenstate 的输入状态，这意味着如果 $U （m） \ket{\phi\_j} = e ^ {im\phi\_j} $，则阶段估算的进程将不确定地将量程状态引导到单个能源 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="9f52a-132">If an input state is provided that is not an eigenstate, which is to say that if $U(m)\ket{\phi\_j} = e^{im\phi\_j}$ then the process of phase estimation non-deterministically guides the quantum state towards a single energy eigenstate.</span></span>  <span data-ttu-id="9f52a-133">它最终聚合为的 eigenstate 是最有可能产生观察 `Result`的 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="9f52a-133">The eigenstate it ultimately converges to is the eigenstate that is most likely to produce the observed `Result`.</span></span>

<span data-ttu-id="9f52a-134">具体而言，PE 的单个步骤会在状态 \begin{align} \ sum_j \sqrt{\Pr （\phi\_j）} \ket{\phi\_j} \mapsto \sum\_j\frac {\ sqrt {\ Pr 上执行以下非单一转换（\phi\_j）} \sqrt{\Pr （\text{Result} | \phi\_j）} \ket{\phi\_j}} {\sqrt{\Pr （\phi\_j） \sum\_j \Pr （\text{Result} | \phi\_j）}}。</span><span class="sxs-lookup"><span data-stu-id="9f52a-134">Specifically, a single step of PE performs the following non-unitary transformation on a state \begin{align} \sum_j \sqrt{\Pr(\phi\_j)} \ket{\phi\_j} \mapsto \sum\_j\frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}.</span></span>
<span data-ttu-id="9f52a-135">\end{align}，因为此过程是通过多个 `Result` 值进行迭代的，所以不具有最大值 $ \ prod_k \Pr （\text{Result}\_k | \phi\_j） $ 的 eigenstates 将被指数地抑制。</span><span class="sxs-lookup"><span data-stu-id="9f52a-135">\end{align} As this process is iterated over multiple `Result` values, eigenstates that do not have maximal values of $\prod_k\Pr(\text{Result}\_k|\phi\_j)$ will be exponentially suppressed.</span></span>
<span data-ttu-id="9f52a-136">这样一来，如果正确选择了试验，推理过程将成为一种 eigenvalue 的状态。</span><span class="sxs-lookup"><span data-stu-id="9f52a-136">As a result, the inference process will tend to converge to states with a single eigenvalue if the experiments are chosen properly.</span></span>

<span data-ttu-id="9f52a-137">Bayes ' 定理进一步建议以 \begin{align} \frac{\sqrt{\Pr （\phi\_j）} \sqrt{\Pr （\text{Result} | \phi\_j）} \ket{\phi （\Sqrt{\Pr | \phi j）} \sum\_j}} {\Pr （\text{Result}\_j） \phi\_j \Sqrt{\Pr （\Phi | \text{Result}\_</span><span class="sxs-lookup"><span data-stu-id="9f52a-137">Bayes' theorem further suggests that the state that results from phase estimation be written in the form \begin{align} \frac{\sqrt{\Pr(\phi\_j)}\sqrt{\Pr(\text{Result}|\phi\_j)}\ket{\phi\_j}}{\sqrt{\Pr(\phi\_j)\sum\_j \Pr(\text{Result}|\phi\_j)}}=\sum_j \sqrt{\Pr(\phi\_j|\text{Result})} \ket{\phi\_j}.</span></span>
<span data-ttu-id="9f52a-138">此处的 \end{align} $ \Pr （\phi\_j | \text{Result}） $ 可以解释为每个假设应 ascribe 给每个假设的概率：</span><span class="sxs-lookup"><span data-stu-id="9f52a-138">\end{align} Here $\Pr(\phi\_j|\text{Result})$ can be interpretted as the probability that one would ascribe to each hypothesis about the eigenstates given:</span></span>

1. <span data-ttu-id="9f52a-139">计量之前的量程状态的知识，</span><span class="sxs-lookup"><span data-stu-id="9f52a-139">knowledge of the quantum state prior to measurement,</span></span>
2. <span data-ttu-id="9f52a-140">了解 $U $ 和的 eigenstates</span><span class="sxs-lookup"><span data-stu-id="9f52a-140">knowledge of the eigenstates of $U$ and,</span></span>
3. <span data-ttu-id="9f52a-141">$U $ 的本征值的知识。</span><span class="sxs-lookup"><span data-stu-id="9f52a-141">knowledge of the eigenvalues of $U$.</span></span>

<span data-ttu-id="9f52a-142">了解这三个问题在传统计算机上通常是呈指数级的。</span><span class="sxs-lookup"><span data-stu-id="9f52a-142">Learning these three things is often exponentially hard on a classical computer.</span></span>
<span data-ttu-id="9f52a-143">从一开始就可以执行这样一种量程学习任务，而无需知道阶段估算的实用程序。</span><span class="sxs-lookup"><span data-stu-id="9f52a-143">The utility of phase estimation arises, to no small extent, from the fact that it can perform such a quantum learning task without knowing any of them.</span></span>
<span data-ttu-id="9f52a-144">此原因的阶段估算出现在提供指数加速的多个量程算法中。</span><span class="sxs-lookup"><span data-stu-id="9f52a-144">Phase estimation for this reason appears within a number of quantum algorithms that provide exponential speedups.</span></span>

### <a name="bayesian-phase-estimation"></a><span data-ttu-id="9f52a-145">Bayesian 阶段估算</span><span class="sxs-lookup"><span data-stu-id="9f52a-145">Bayesian Phase Estimation</span></span> ###

> [!TIP]
> <span data-ttu-id="9f52a-146">有关 Bayesian 阶段估算的详细信息，请参阅[**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation)示例。</span><span class="sxs-lookup"><span data-stu-id="9f52a-146">For more details on Bayesian phase estimation in practice, please see the [**PhaseEstimation**](https://github.com/microsoft/Quantum/tree/master/samples/characterization/phase-estimation) sample.</span></span>

<span data-ttu-id="9f52a-147">Bayesian 阶段估算的理念非常简单。</span><span class="sxs-lookup"><span data-stu-id="9f52a-147">The idea of Bayesian phase estimation is simple.</span></span>
<span data-ttu-id="9f52a-148">从阶段估算协议收集度量值统计信息，然后使用 Bayesian 推理来处理结果，并提供参数的估计值。</span><span class="sxs-lookup"><span data-stu-id="9f52a-148">You collect measurement statistics from the phase estimation protocol and then you process the results using Bayesian inference and provide an estimate of the parameter.</span></span>
<span data-ttu-id="9f52a-149">此处理可让你估计 eigenvalue 以及该估计值的不确定性。</span><span class="sxs-lookup"><span data-stu-id="9f52a-149">This processing gives you an estimate of the eigenvalue as well as the uncertainty in that estimate.</span></span>
<span data-ttu-id="9f52a-150">它还允许您执行自适应试验并利用以前的信息。</span><span class="sxs-lookup"><span data-stu-id="9f52a-150">It also allows you to perform adaptive experiments and utilize prior information.</span></span>
<span data-ttu-id="9f52a-151">方法的主要缺点是它需要进行计算。</span><span class="sxs-lookup"><span data-stu-id="9f52a-151">The methods' principle drawback is that it is computationally demanding.</span></span>

<span data-ttu-id="9f52a-152">若要了解此 Bayesian 推理过程的工作原理，请考虑处理单个 `Zero` 结果的情况。</span><span class="sxs-lookup"><span data-stu-id="9f52a-152">To understand how this Bayesian inference process works, consider the case of processing a single `Zero` result.</span></span>
<span data-ttu-id="9f52a-153">请注意，$X = \ket{+} \bra{+}-\ket{-}\bra{-}$，这样，$ \ket{+} $ 就是对应于 `Zero`的 $X $ 的唯一肯定 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="9f52a-153">Note that $X = \ket{+}\bra{+} - \ket{-}\bra{-}$, such that $\ket{+}$ is the only positive eigenstate of $X$ corresponding to `Zero`.</span></span>
<span data-ttu-id="9f52a-154">在给定输入状态 $ \ket{\psi}\ket{\phi} $ 的情况 qubit，在第一个上 `Zero` 观察[`PauliX` 度量值](xref:microsoft.quantum.concepts.pauli)的概率，因此 \begin{equation} \Pr （\texttt{Zero} | \psi） = \left |\braket{+ | \psi} \right | ^ 2。</span><span class="sxs-lookup"><span data-stu-id="9f52a-154">The probability of observing `Zero` for a [`PauliX` measurement](xref:microsoft.quantum.concepts.pauli) on the first qubit given an input state $\ket{\psi}\ket{\phi}$ is thus \begin{equation} \Pr(\texttt{Zero} | \psi) = \left| \braket{+ | \psi} \right|^2.</span></span>
<span data-ttu-id="9f52a-155">\end{equation} 在迭代阶段估算的情况下，我们已将 $ \ket{\psi} = R_1 （m [\phi-\theta]） \ket{+} $，以便 \begin{align} \Pr （\texttt{Zero} | \phi; m，\theta） & = \left |\braket{+ |R_1 （m [\phi-\theta]） |+} \right | ^ 2 \\\\ & = \left |\frac12 \left （\bra{0} + \bra{1} \right） \left （\ket{0} + e ^ {i m [\phi-\theta]} \ket{1} \right） \right | ^ 2 \\\\ & = \left |\frac{1 + e ^ {i m [\phi-\theta]}}{2} \right | ^ 2 \\\\ & = \cos ^ 2 （m [\phi-\theta]/2） \tag{★} \label{eq：。</span><span class="sxs-lookup"><span data-stu-id="9f52a-155">\end{equation} In the case of iterative phase estimation, we have that $\ket{\psi} = R_1(m [\phi-\theta]) \ket{+}$, such that \begin{align} \Pr(\texttt{Zero} | \phi; m,\theta) & = \left| \braket{+ | R_1(m [\phi-\theta]) | +} \right|^2 \\\\ & = \left| \frac12 \left( \bra{0} + \bra{1} \right) \left( \ket{0} + e^{i m [\phi-\theta]} \ket{1} \right) \right|^2 \\\\ & = \left| \frac{1 + e^{i m [\phi-\theta]}}{2} \right|^2 \\\\ & = \cos^2(m [\phi-\theta] / 2) \tag{★} \label{eq:phase-est-likelihood}.</span></span>
<span data-ttu-id="9f52a-156">\end{align} 是迭代阶段估算，其中包含正弦函数的振荡频率，因为能够使用该 sinusoid 给定的偏移量来翻转硬币。</span><span class="sxs-lookup"><span data-stu-id="9f52a-156">\end{align} That is, iterative phase estimation consists of learning the oscillation frequency of a sinusoidal function, given the ability to flip a coin with a bias given by that sinusoid.</span></span>
<span data-ttu-id="9f52a-157">按照传统的传统术语，我们调用了 $ \eqref{eq：时间-est-est} $*概率函数*以进行迭代阶段估算。</span><span class="sxs-lookup"><span data-stu-id="9f52a-157">Following traditional classical terminology, we call $\eqref{eq:phase-est-likelihood}$ the *likelihood function* for iterative phase estimation.</span></span>

<span data-ttu-id="9f52a-158">在观察到迭代阶段估算可能性函数的 `Result` 后，就可以使用 Bayes 的规则来规定应该将该阶段确定为遵循该观察阶段。</span><span class="sxs-lookup"><span data-stu-id="9f52a-158">Having observed a `Result` from the iterative phase estimation likelihood function, we can then use Bayes' rule to prescribe what we should believe the phase to be following that observation.</span></span>
<span data-ttu-id="9f52a-159">具体而言，\begin{equation} \Pr （\phi | d） = \frac{\Pr （d | \phi） \Pr （\phi）} {\int \Pr （d | \phi） \Pr （\phi） {\mathrm d} \phi} \Pr （\phi），\end{equation}，其中 $d \in \\{\texttt{Zero}，\texttt{One}\\} $ 是 `Result`，其中 $ \Pr （\phi） $ 描述了之前的信仰 $ \phi $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-159">Concretely, \begin{equation} \Pr(\phi | d) = \frac{\Pr(d | \phi) \Pr(\phi)}{\int \Pr(d | \phi) \Pr(\phi){\mathrm d}\phi} \Pr(\phi), \end{equation} where $d \in \\{\texttt{Zero}, \texttt{One}\\}$ is a `Result`, and where $\Pr(\phi)$ describes our prior beliefs about $\phi$.</span></span>
<span data-ttu-id="9f52a-160">然后，这会使迭代阶段的迭代本质明确明了，因为后验分布 $ \Pr （\phi | d） $ 介绍了我们的信仰，紧靠下一个 `Result`。</span><span class="sxs-lookup"><span data-stu-id="9f52a-160">This then makes the iterative nature of iterative phase estimation explicit, as the posterior distribution $\Pr(\phi | d)$ describes our beliefs immediately preceeding our observation of the next `Result`.</span></span>

<span data-ttu-id="9f52a-161">在此过程中，我们可以在此过程中的任何时间点将古典控制器推导为 \begin{equation} \hat{\phi} \mathrel{： =} \expect [\phi | \text{data}] = \int \phi \Pr （\phi | \text{data}） {\mathrm d} \phi，\end{equation}，其中 $ \text{data} $ 代表获得的所有 `Result` 值的整个记录。</span><span class="sxs-lookup"><span data-stu-id="9f52a-161">At any point during this procedure, we can report the phase $\hat{\phi}$ inferred by the classical controller as \begin{equation} \hat{\phi} \mathrel{:=} \expect[\phi | \text{data}] = \int \phi \Pr(\phi | \text{data}) {\mathrm d}\phi, \end{equation} where $\text{data}$ stands for the entire record of all `Result` values obtained.</span></span>

<span data-ttu-id="9f52a-162">确切的 Bayesian 推理在实践棘手中。</span><span class="sxs-lookup"><span data-stu-id="9f52a-162">Exact Bayesian inference is in practice intractable.</span></span>
<span data-ttu-id="9f52a-163">为此，我们想要了解 $x $ $n $ 位变量。</span><span class="sxs-lookup"><span data-stu-id="9f52a-163">To see this imagine we wish to learn an $n$-bit variable $x$.</span></span>
<span data-ttu-id="9f52a-164">之前的分发 $ \Pr （x） $ 支持 $x $ 的 $ 2 ^ n $ 假设值。</span><span class="sxs-lookup"><span data-stu-id="9f52a-164">The prior distribution $\Pr(x)$ has support over $2^n$ hypothetical values of $x$.</span></span>
<span data-ttu-id="9f52a-165">这意味着，如果需要对 $x $ 进行非常准确的估计，Bayesian 阶段估计可能需要内存和处理时间不高。</span><span class="sxs-lookup"><span data-stu-id="9f52a-165">This means that if we need a highly accurate estimate of $x$ then Bayesian phase estimation may need prohibitive memory and processing time.</span></span>
<span data-ttu-id="9f52a-166">对于某些应用程序，如量程模拟，所需的 limitted 准确性不会排除这样的方法。其他应用程序（如选定的算法）在其阶段估算步骤内不能使用精确的 Bayesian 推理。</span><span class="sxs-lookup"><span data-stu-id="9f52a-166">While for some applications, such as quantum simulation, the limitted accuracy required does not preclude such methods other applications, such as Shor's algorithm, cannot use exact Bayesian inference within its phase estimation step.</span></span>  <span data-ttu-id="9f52a-167">出于此原因，我们还提供了近似 Bayesian 方法（如[随机审核阶段估算（RWPE））](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation)和非 Bayesian 方法（如可靠的[阶段估算](xref:microsoft.quantum.characterization.robustphaseestimation)）的实现。</span><span class="sxs-lookup"><span data-stu-id="9f52a-167">For this reason, we also provide implementations for approximate Bayesian methods such as [random walk phase estimation (RWPE)](xref:microsoft.quantum.research.randomwalkphaseestimation.randomwalkphaseestimation) and also non-Bayesian approaches such as [robust phase estimation](xref:microsoft.quantum.characterization.robustphaseestimation).</span></span>

### <a name="robust-phase-estimation"></a><span data-ttu-id="9f52a-168">可靠阶段估算</span><span class="sxs-lookup"><span data-stu-id="9f52a-168">Robust Phase Estimation</span></span> ###

<span data-ttu-id="9f52a-169">最大情况下，最大值为 " *posteriori* Bayesian" 的最大阶段，即从测量结果中重建阶段估算。</span><span class="sxs-lookup"><span data-stu-id="9f52a-169">A maximum *a posteriori* Bayesian reconstruction of a phase estimate from measurement results is exponentially hard in the worst-case.</span></span> <span data-ttu-id="9f52a-170">因此，大多数可行的阶段估算算法在重建中会牺牲一定的质量，而在 exchange 中，这种情况下，会将 polynomially 与进行的度量值进行缩放。</span><span class="sxs-lookup"><span data-stu-id="9f52a-170">Thus most practical phase estimation algorithms sacrifice some quality in the reconstruction, in exchange for an amount of classical post-processing that instead scales polynomially with the number of measurements made.</span></span>

<span data-ttu-id="9f52a-171">一个这样的示例（一个有效的传统后处理步骤）是[可靠的阶段估算算法](https://arxiv.org/abs/1502.02677)，其签名和输入如下所述。</span><span class="sxs-lookup"><span data-stu-id="9f52a-171">One such example with an efficient classical post-processing step is the [robust phase estimation algorithm](https://arxiv.org/abs/1502.02677), with its signature and inputs mentioned above.</span></span> <span data-ttu-id="9f52a-172">它假定输入单一的黑框 $U $ 封装为 `DiscreteOracle` 类型，因此仅查询受控 $U $ 的整数幂。</span><span class="sxs-lookup"><span data-stu-id="9f52a-172">It assumes that input unitary black-boxes $U$ are packaged as `DiscreteOracle` type, and therefore only queries integer powers of controlled-$U$.</span></span> <span data-ttu-id="9f52a-173">如果 `Qubit[]` register 中的输入状态为 eigenstate $U \ket{\psi} = e ^ {i\phi} \ 票证 {\ psi} $，则可靠阶段估算算法会将 $ \hat{\phi}\in $ 的估算值返回为 `Double`。</span><span class="sxs-lookup"><span data-stu-id="9f52a-173">If the input state in the `Qubit[]` register is an eigenstate $U\ket{\psi}=e^{i\phi}\ket{\psi}$, the robust phase estimation algorithm returns an estimate $\hat{\phi}\in[-\pi,\pi)$ of $\phi$ as a `Double`.</span></span>

<span data-ttu-id="9f52a-174">与大多数其他有用的变体共享的可靠阶段估算的最重要功能是，$ \hat{\phi} $ 的重建质量在某种意义上是海森堡的。</span><span class="sxs-lookup"><span data-stu-id="9f52a-174">The most important feature of robust phase estimation, which is shared with most other useful variants, is that the reconstruction quality of $\hat{\phi}$ is in some sense Heisenberg-limited.</span></span> <span data-ttu-id="9f52a-175">这意味着，如果从 true 值到 $ \sigma $，$ \hat{\phi} $ 的偏差为 $ \sigma $，则 $ $ 将按对受控-$U $ （即 $ \sigma = \mathcal{O} （1/Q） $ 进行的 $Q 查询总数成反比。</span><span class="sxs-lookup"><span data-stu-id="9f52a-175">This means that if the deviation of $\hat{\phi}$ from the true value is $\sigma$, then $\sigma$ scales inversely-proportional to the total number of queries $Q$ made to controlled-$U$, i.e. $\sigma=\mathcal{O}(1/Q)$.</span></span> <span data-ttu-id="9f52a-176">现在，偏差定义在不同的估计算法之间有所不同。</span><span class="sxs-lookup"><span data-stu-id="9f52a-176">Now, the definition of deviation varies between different estimation algorithms.</span></span> <span data-ttu-id="9f52a-177">在某些情况下，这可能意味着至少有 $ \mathcal{O} （1） $ 概率，估计错误 $ | \hat{\phi}-\phi |\_\circ\le \sigma $ on a 循环度量 $ \circ $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-177">In some cases, it may mean that with at least $\mathcal{O}(1)$ probability, the estimation error $|\hat{\phi}-\phi|\_\circ\le \sigma$ on some circular measure $\circ$.</span></span> <span data-ttu-id="9f52a-178">对于可靠的阶段估算，偏差精确到 $ \sigma ^ 2 = \mathbb{E}\_\hat{\phi} [（\mod\_{2 \ pi} （\hat{\phi}-\phi + \pi）-\pi） ^ 2] $ 如果将定期阶段解为单个有限间隔 $ （-\pi，\pi] $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-178">For robust phase estimation, deviation is precisely the variance $\sigma^2 = \mathbb{E}\_\hat{\phi}[(\mod\_{2\pi}(\hat{\phi}-\phi +\pi)-\pi)^2]$ if we unwrap periodic phases onto a single finite interval $(-\pi,\pi]$.</span></span> <span data-ttu-id="9f52a-179">更准确地说，可靠阶段估算中的标准偏差满足不相等 $ $ \begin{align} 2.0 \pi/Q \le \sigma \le 2 \ pi/2 ^ {n} \le 10.7 \ pi/Q，\end{align} $ $，其中的下限达到了 asymptotically 大 $Q $ 的限制，并且即使是小型样本大小也可保证上限。</span><span class="sxs-lookup"><span data-stu-id="9f52a-179">More precisely, the standard deviation in robust phase estimation satisfies the inequalities $$ \begin{align} 2.0 \pi / Q \le \sigma \le 2\pi / 2^{n} \le 10.7\pi / Q, \end{align} $$ where the lower bound is reached in the limit of asymptotically large $Q$, and the upper bound is guaranteed even for small sample sizes.</span></span>  <span data-ttu-id="9f52a-180">请注意，$n 由 `bitsPrecision` 输入选择的 $，它隐式定义 $Q $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-180">Note that $n$ selected by the `bitsPrecision` input, which implicitly defines $Q$.</span></span>

<span data-ttu-id="9f52a-181">其他相关的详细信息包括：仅 $1 $ ancilla qubit 的小空间开销，或该过程是非自适应，这意味着所需的量程试验顺序与中间测量结果无关。</span><span class="sxs-lookup"><span data-stu-id="9f52a-181">Other relevant details include, say, the small space overhead of just $1$ ancilla qubit, or that the procedure is non-adaptive, meaning the required sequence of quantum experiments is independent of the intermediate measurement outcomes.</span></span> <span data-ttu-id="9f52a-182">在此示例中，如果选择阶段估算算法非常重要，其中一项应引用文档（如 @"microsoft.quantum.canon.robustphaseestimation"）和引用的发布，以获取详细信息及其实现。</span><span class="sxs-lookup"><span data-stu-id="9f52a-182">In this and forthcoming examples where the choice of phase estimation algorithm is important, one should one should refer to the documentation such as @"microsoft.quantum.canon.robustphaseestimation" and the referenced publications therein for more information and for their the implementation.</span></span>

> [!TIP]
> <span data-ttu-id="9f52a-183">在许多示例中，使用了可靠的阶段估算。</span><span class="sxs-lookup"><span data-stu-id="9f52a-183">There are many samples where robust phase estimation is used.</span></span> <span data-ttu-id="9f52a-184">有关提取各个物理系统的地面状态能量的阶段估算，请参阅[ **H2 模拟**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line)、 [ **SimpleIsing**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple)和[ **Hubbard 模型**示例](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard)。</span><span class="sxs-lookup"><span data-stu-id="9f52a-184">For phase estimation in extracting the ground state energy of various physical system, please see the [**H2 simulation** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/h2/command-line), the [**SimpleIsing** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/ising/simple), and the [**Hubbard model** sample](https://github.com/microsoft/Quantum/tree/master/samples/simulation/hubbard).</span></span>


### <a name="continuous-oracles"></a><span data-ttu-id="9f52a-185">连续 Oracles</span><span class="sxs-lookup"><span data-stu-id="9f52a-185">Continuous Oracles</span></span> ###

<span data-ttu-id="9f52a-186">我们还可以从上述 oracle 模型通用化，以允许按 canon 类型 <xref:microsoft.quantum.oracles.continuousoracle>建模的持续时间 oracles。</span><span class="sxs-lookup"><span data-stu-id="9f52a-186">We can also generalize from the oracle model used above to allow for continuous-time oracles, modeled by the canon type <xref:microsoft.quantum.oracles.continuousoracle>.</span></span>
<span data-ttu-id="9f52a-187">请考虑不要使用单个单一运算符 $U $，而是 $t \in \mathbb{R} $ 中有一个单一运算符系列 $U （t） $，这样 $U （t） U （s） $ = $U （t + s） $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-187">Consider that instead of a single unitary operator $U$, we have a family of unitary operators $U(t)$ for $t \in \mathbb{R}$ such that $U(t) U(s)$ = $U(t + s)$.</span></span>
<span data-ttu-id="9f52a-188">这是一个比离散大小写更弱的语句，因为我们可以通过将 $t = m\,\delta t $ 限制为某个固定的 $ \delta t $ 来构造 <xref:microsoft.quantum.oracles.discreteoracle>。</span><span class="sxs-lookup"><span data-stu-id="9f52a-188">This is a weaker statement than in the discrete case, since we can construct a <xref:microsoft.quantum.oracles.discreteoracle> by restricting $t = m\,\delta t$ for some fixed $\delta t$.</span></span>
<span data-ttu-id="9f52a-189">按[石头的定理](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups)，$U （t） = \exp （i H t） $ for a operator $H $，其中 $ \exp $ 是矩阵指数，如[高级矩阵](xref:microsoft.quantum.concepts.matrix-advanced)中所述。</span><span class="sxs-lookup"><span data-stu-id="9f52a-189">By [Stone's theorem](https://en.wikipedia.org/wiki/Stone%27s_theorem_on_one-parameter_unitary_groups), $U(t) = \exp(i H t)$ for some operator $H$, where $\exp$ is the matrix exponential as described in [advanced matrices](xref:microsoft.quantum.concepts.matrix-advanced).</span></span>
<span data-ttu-id="9f52a-190">Eigenstate $ \ket{\phi} $ of $H $，因此 $H \ket{\phi} = \phi \ket{\phi} $ 还 $U （t） $，适用于所有 $t $，eigenstate U （t） \begin{equation} = e ^ {i \ket{\phi} t} \phi</span><span class="sxs-lookup"><span data-stu-id="9f52a-190">An eigenstate $\ket{\phi}$ of $H$ such that $H \ket{\phi} = \phi \ket{\phi}$ is then also an eigenstate of $U(t)$ for all $t$, \begin{equation} U(t) \ket{\phi} = e^{i \phi t} \ket{\phi}.</span></span>
<span data-ttu-id="9f52a-191">\end{equation}</span><span class="sxs-lookup"><span data-stu-id="9f52a-191">\end{equation}</span></span>

<span data-ttu-id="9f52a-192">可以应用对[Bayesian 阶段估算](#bayesian-phase-estimation)讨论的完全相同的分析，并且可能性函数对于此更常规的 oracle 模型是完全相同的： $ $ \Pr （\texttt{Zero} | \phi; t，\theta） = \cos ^ 2 \ 左（\frac{t [\phi-\theta]}{2}\right）。</span><span class="sxs-lookup"><span data-stu-id="9f52a-192">The exact same analysis discussed for [Bayesian phase estimation](#bayesian-phase-estimation) can be applied, and the likelihood function is the precisely the same for this more general oracle model: $$ \Pr(\texttt{Zero} | \phi; t,\theta)=\cos^2\left(\frac{t[\phi -\theta]}{2}\right).</span></span>
<span data-ttu-id="9f52a-193">$ $ 而且，如果 $U $ 是 dynamical 生成器的模拟， [Hamiltonian 模拟](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation)情况下，我们会将 $ \phi $ 解释为能源。</span><span class="sxs-lookup"><span data-stu-id="9f52a-193">$$ Moreover, if $U$ is a simulation of a dynamical generator, as is the case for [Hamiltonian simulation](xref:microsoft.quantum.libraries.applications#hamiltonian-simulation), we interpret $\phi$ as an energy.</span></span>
<span data-ttu-id="9f52a-194">因此，通过连续查询使用阶段估算，可以了解分子、[材料](https://arxiv.org/abs/1510.03859)或[现场理论](https://arxiv.org/abs/1111.3633v2)的模拟[能源](https://arxiv.org/abs/quant-ph/0604193)，无需通过要求将 $t $ 为整数来损害我们选择的实验。</span><span class="sxs-lookup"><span data-stu-id="9f52a-194">Thus, using phase estimation with continuous queries allows us to learn the simulated [energy spectrum of molecules](https://arxiv.org/abs/quant-ph/0604193), [materials](https://arxiv.org/abs/1510.03859) or [field theories](https://arxiv.org/abs/1111.3633v2) without having to compromise our choice of experiments by requiring $t$ to be an integer.</span></span>

### <a name="random-walk-phase-estimation"></a><span data-ttu-id="9f52a-195">随机审核阶段估算</span><span class="sxs-lookup"><span data-stu-id="9f52a-195">Random Walk Phase Estimation</span></span> ###

<span data-ttu-id="9f52a-196">Q # 提供了一个非常有用的 Bayesian 阶段估算，旨在使用接近于量程的设备，这些设备通过对从迭代阶段估算获取的数据记录进行随机审核来进行。</span><span class="sxs-lookup"><span data-stu-id="9f52a-196">Q# provides a useful approximation of Bayesian phase estimation designed for use close to quantum devices that operates by conditioning a random walk on the data record obtained from iterative phase estimation.</span></span>
<span data-ttu-id="9f52a-197">此方法既是自适应的，也是完全确定性的，允许在估计阶段 $ \hat{\phi} $ 中的错误中进行近乎最佳的缩放，内存开销非常低。</span><span class="sxs-lookup"><span data-stu-id="9f52a-197">This method is both adaptive and entirely deterministic, allowing for near-optimal scaling of errors in the estimated phase $\hat{\phi}$ with very low memory overheads.</span></span>

<span data-ttu-id="9f52a-198">协议使用近似的 Bayesian 推理方法，该方法假定之前的分布是高斯。</span><span class="sxs-lookup"><span data-stu-id="9f52a-198">The protocol uses an approximate Bayesian inference method that assumes the prior distribution is Gaussian.</span></span>
<span data-ttu-id="9f52a-199">此高斯假设允许使用分析公式来最大程度地减少后验方差。</span><span class="sxs-lookup"><span data-stu-id="9f52a-199">This Gaussian assumption allows us to use an analytical formula for the experiment that minimizes the posterior variance.</span></span>
<span data-ttu-id="9f52a-200">然后，该算法将根据该实验的结果，将 $ \phi $ 的估计值向左或向右移动一个预先确定的量，并按预先确定的量来缩减该方差。</span><span class="sxs-lookup"><span data-stu-id="9f52a-200">The algorithm then, based on the outcome of that experiment, shifts the estimate of $\phi$ left or right by a pre-determined amount and shrinks the variance by a pre-determined amount.</span></span>
<span data-ttu-id="9f52a-201">此平均值和方差为下一次试验提供了在 $ \phi $ 之前指定高斯所需的所有信息。</span><span class="sxs-lookup"><span data-stu-id="9f52a-201">This mean and variance give all the information that is needed to specify a Gaussian prior on $\phi$ for the next experiment.</span></span>
<span data-ttu-id="9f52a-202">意外的度量失败，或在初始之前的反面上的实际结果可能导致此方法失败。</span><span class="sxs-lookup"><span data-stu-id="9f52a-202">Unexpected measurement failures, or the true result being on the tails of the initial prior, can cause this method to fail.</span></span>
<span data-ttu-id="9f52a-203">它通过执行试验来测试当前平均值和标准偏差是否适用于系统，从而从失败中恢复。</span><span class="sxs-lookup"><span data-stu-id="9f52a-203">It recovers from failure by performing experiments to test whether the current mean and standard deviation are appropriate for the system.</span></span>
<span data-ttu-id="9f52a-204">如果不是，则该算法将执行遍历的反向步骤，并继续执行该过程。</span><span class="sxs-lookup"><span data-stu-id="9f52a-204">If they are not, then the algorithm does an inverse step of the walk and the process continues.</span></span>
<span data-ttu-id="9f52a-205">单步执行的功能还允许该算法了解，即使初始之前的标准偏差 inapropriately 小也是如此。</span><span class="sxs-lookup"><span data-stu-id="9f52a-205">The ability to step backwards also allows the algorithm to learn even if the initial prior standard deviation is inapropriately small.</span></span>

## <a name="calling-phase-estimation-algorithms"></a><span data-ttu-id="9f52a-206">调用阶段估算算法</span><span class="sxs-lookup"><span data-stu-id="9f52a-206">Calling Phase Estimation Algorithms</span></span> ##

<span data-ttu-id="9f52a-207">使用 Q # canon 提供的每个阶段估计操作采用一组不同的输入，参数化从最终估计 $ \hat{\phi} $ 中所需的质量。</span><span class="sxs-lookup"><span data-stu-id="9f52a-207">Each phase estimation operation provided with the Q# canon takes a different set of inputs parameterizing the quality that we demand out of the final estimate $\hat{\phi}$.</span></span>
<span data-ttu-id="9f52a-208">但这些不同的输入都有多个共同的输入，因此，部分应用程序的质量参数导致公共签名。</span><span class="sxs-lookup"><span data-stu-id="9f52a-208">These various inputs, however, all share several inputs in common, such that partial application over the quality parameters results in a common signature.</span></span>
<span data-ttu-id="9f52a-209">例如，在下一部分中讨论的 <xref:microsoft.quantum.characterization.robustphaseestimation> 操作具有以下签名：</span><span class="sxs-lookup"><span data-stu-id="9f52a-209">For example, the <xref:microsoft.quantum.characterization.robustphaseestimation> operation discussed in the next section has the following signature:</span></span>

```qsharp
operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
```

<span data-ttu-id="9f52a-210">`bitsPrecision` 输入对于 `RobustPhaseEstimation`是唯一的，而 `oracle` 和 `eigenstate` 是通用的。</span><span class="sxs-lookup"><span data-stu-id="9f52a-210">The `bitsPrecision` input is unique to `RobustPhaseEstimation`, while `oracle` and `eigenstate` are in common.</span></span>
<span data-ttu-id="9f52a-211">因此，如**H2Sample**中所示，操作可以接受具有格式 `(DiscreteOracle, Qubit[]) => Unit` 的迭代阶段估算算法，以允许用户指定任意阶段估算算法：</span><span class="sxs-lookup"><span data-stu-id="9f52a-211">Thus, as seen in **H2Sample**, an operation can accept an iterative phase estimation algorithm with an input of the form `(DiscreteOracle, Qubit[]) => Unit` to allow a user to specify arbitrary phase estimation algorithms:</span></span>

```qsharp
operation H2EstimateEnergy(
    idxBondLength : Int, 
    trotterStepSize : Double,
    phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) 
: Double
```

<span data-ttu-id="9f52a-212">这些无数阶段估算算法针对不同的属性和输入参数进行了优化，这些属性和输入参数必须被理解为目标应用程序的最佳选择。</span><span class="sxs-lookup"><span data-stu-id="9f52a-212">These myriad phase estimation algorithms are optimized for different properties and input parameters, which must be understood to make the best choice for the target application.</span></span> <span data-ttu-id="9f52a-213">例如，某些阶段估算算法是自适应的，这意味着，以后的步骤经典由前面步骤的测量结果控制。</span><span class="sxs-lookup"><span data-stu-id="9f52a-213">For instance, some phase estimation algorithms are adaptive, meaning that future steps are classically controlled by the measurement results of previous steps.</span></span> <span data-ttu-id="9f52a-214">有些情况下，需要能够通过任意实际的 exponentiate 来其黑洞的单一 oracle，而其他人只需使用整数，而只需要解析阶段估算 $ 2 \ pi $。</span><span class="sxs-lookup"><span data-stu-id="9f52a-214">Some require the ability to exponentiate its black-box unitary oracle by arbitrary real powers, and others only require integer powers but are only able to resolve a phase estimate modulo $2\pi$.</span></span> <span data-ttu-id="9f52a-215">有些需要多个辅助 qubits，而另一个只需要一个。</span><span class="sxs-lookup"><span data-stu-id="9f52a-215">Some require many auxillary qubits, and other require only one.</span></span>

<span data-ttu-id="9f52a-216">同样，使用随机审核阶段估算的方式与 canon 提供的其他算法的执行方式几乎相同：</span><span class="sxs-lookup"><span data-stu-id="9f52a-216">Similarly, using random walk phase estimation proceeds in much the same way as for other algorithms provided with the canon:</span></span>

```qsharp
operation ExampleOracle(eigenphase : Double, time : Double, register : Qubit[]) : Unit
is Adj + Ctl {
    Rz(2.0 * eigenphase * time, register[0]);
}

operation BayesianPhaseEstimationCanonSample(eigenphase : Double) : Double {

    let oracle = ContinuousOracle(ExampleOracle(eigenphase, _, _));
    using (eigenstate = Qubit()) {
        X(eigenstate);
        // The additional inputs here specify the mean and variance of the prior, the number of
        // iterations to perform, how many iterations to perform as a maximum, and how many
        // steps to roll back on an approximation failure.
        let est = RandomWalkPhaseEstimation(0.0, 1.0, 61, 100000, 1, oracle, [eigenstate]);
        Reset(eigenstate);
        return est;
    }
}
```
