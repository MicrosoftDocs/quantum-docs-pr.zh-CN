---
title: 量程计算中的 qubit
description: 了解 qubits，这是量程计算中信息的基本单位。
author: QuantumWriter
uid: microsoft.quantum.concepts.qubit
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f5e5c2a66899c552ad39e63703c34718818b1452
ms.sourcegitcommit: 2317473fdf2b80de58db0f43b9fcfb57f56aefff
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 05/15/2020
ms.locfileid: "83426958"
---
# <a name="the-qubit"></a><span data-ttu-id="75a7f-103">Qubit</span><span class="sxs-lookup"><span data-stu-id="75a7f-103">The Qubit</span></span>

<span data-ttu-id="75a7f-104">就像在传统计算中信息的基础对象一样， [*qubits*](https://en.wikipedia.org/wiki/Qubit) （量程位）是量程计算中信息的基础对象。</span><span class="sxs-lookup"><span data-stu-id="75a7f-104">Just as bits are the fundamental object of information in classical computing, [*qubits*](https://en.wikipedia.org/wiki/Qubit) (quantum bits) are the fundamental object of information in quantum computing.</span></span>  <span data-ttu-id="75a7f-105">为了理解这一函件，让我们看看一个简单的示例：单个 qubit。</span><span class="sxs-lookup"><span data-stu-id="75a7f-105">To understand this correspondence, let's look at the simplest example: a single qubit.</span></span>

## <a name="representing-a-qubit"></a><span data-ttu-id="75a7f-106">表示 Qubit</span><span class="sxs-lookup"><span data-stu-id="75a7f-106">Representing a Qubit</span></span>

<span data-ttu-id="75a7f-107">虽然位或二进制数字的值可以是 $0 $ 或 $1 $，但 qubit 的值可以是这些值，也可以是 superposition 的 $0 $ 和 $1 $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-107">While a bit, or binary digit, can have value either $0$ or $1$, a qubit can have a value that is either of these or a quantum superposition of $0$ and $1$.</span></span>

<span data-ttu-id="75a7f-108">单个 qubit 的状态可以通过单元规范的二维列向量进行描述，也就是说，其条目的大小平方值必须在和 $1 $ 之间。</span><span class="sxs-lookup"><span data-stu-id="75a7f-108">The state of a single qubit can be described by a two-dimensional column vector of unit norm, that is, the magnitude squared of its entries must sum to $1$.</span></span> <span data-ttu-id="75a7f-109">此向量（称为 "量程状态向量"）保存描述 qubit 的量程系统所需的所有信息，只是单个位包含描述二进制变量状态所需的所有信息。</span><span class="sxs-lookup"><span data-stu-id="75a7f-109">This vector, called the quantum state vector, holds all the information needed to describe the one-qubit quantum system just as a single bit holds all of the information needed to describe the state of a binary variable.</span></span>

<span data-ttu-id="75a7f-110">具有标准 $1 $ 的实或复数的任意二维列向量表示 qubit 持有的可能的量程状态。</span><span class="sxs-lookup"><span data-stu-id="75a7f-110">Any two-dimensional column vector of real or complex numbers with norm $1$ represents a possible quantum state held by a qubit.</span></span> <span data-ttu-id="75a7f-111">因此 \\ \\ ，如果 $ qubit $ 和 $ \alpha $ 是满足 $ | \beta | ^ 2 + | \alpha | ^ 2 = $1 的复数，$ \begin{bmatrix} \alpha \beta \end{bmatrix} $ 表示 \beta 状态。</span><span class="sxs-lookup"><span data-stu-id="75a7f-111">Thus $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ represents a qubit state if $\alpha$ and $\beta$ are complex numbers satisfying $|\alpha|^2 + |\beta|^2 = 1$.</span></span> <span data-ttu-id="75a7f-112">表示 qubits 的有效量程状态向量的一些示例包括</span><span class="sxs-lookup"><span data-stu-id="75a7f-112">Some examples of valid quantum state vectors representing qubits include</span></span>

<span data-ttu-id="75a7f-113">$ $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix}，\begin{bmatrix} 0 \\ \\ 1 \end{bmatrix}，\begin{bmatrix} \frac {1} {\sqrt {2} } \\ \\ \frac {1} {\sqrt {2} } \end{bmatrix}，\begin{bmatrix} \frac {1} {\sqrt {2} } \\ \\ \frac {-1} {\sqrt {2} } \end{bmatrix}，\text{and} \begin{bmatrix} \frac {1} {\sqrt {2} } \\ \\ \frac{i}{\sqrt {2} } \end{bmatrix}. $ $</span><span class="sxs-lookup"><span data-stu-id="75a7f-113">$$\begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \begin{bmatrix} 0 \\\\  1 \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{1}{\sqrt{2}} \end{bmatrix}, \begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{-1}{\sqrt{2}} \end{bmatrix}, \text{ and }\begin{bmatrix} \frac{1}{\sqrt{2}} \\\\  \frac{i}{\sqrt{2}} \end{bmatrix}.$$</span></span>

<span data-ttu-id="75a7f-114">量程状态向量 $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $ 和 $ \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $ 采用特殊角色。</span><span class="sxs-lookup"><span data-stu-id="75a7f-114">The quantum state vectors $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ and $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$ take a special role.</span></span> <span data-ttu-id="75a7f-115">这两个向量构成了用于说明 qubit 状态的矢量空间的基础。</span><span class="sxs-lookup"><span data-stu-id="75a7f-115">These two vectors form a basis for the vector space that describes the qubit's state.</span></span> <span data-ttu-id="75a7f-116">这意味着，可以将任何量程状态向量编写为这些基础向量的总和。</span><span class="sxs-lookup"><span data-stu-id="75a7f-116">This means that any quantum state vector can be written as a sum of these basis vectors.</span></span> <span data-ttu-id="75a7f-117">具体而言，矢量 $ \begin{bmatrix} x \\ \\ y \end{bmatrix} $ 可以编写为 $x \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-117">Specifically, the vector $\begin{bmatrix} x \\\\  y \end{bmatrix}$ can be written as $x \begin{bmatrix} 1 \\\\ 0 \end{bmatrix} + y \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="75a7f-118">尽管这些矢量的任何旋转都将作为 qubit 的完全有效基础，但我们选择使用*计算*来处理此类矢量。</span><span class="sxs-lookup"><span data-stu-id="75a7f-118">While any rotation of these vectors would serve as a perfectly valid basis for the qubit, we choose to privilege this one, by calling it the *computational basis*.</span></span>

<span data-ttu-id="75a7f-119">我们将这两个量程状态与传统位的两个状态（即 $0 $ 和 $1 $）相对应。</span><span class="sxs-lookup"><span data-stu-id="75a7f-119">We take these two quantum states to correspond to the two states of a classical bit, namely $0$ and $1$.</span></span> <span data-ttu-id="75a7f-120">标准约定是选择</span><span class="sxs-lookup"><span data-stu-id="75a7f-120">The standard convention is to choose</span></span>

<span data-ttu-id="75a7f-121">$ $ 0 \ http-equiv \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix}，\qquad 1 \equiv \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix}，$ $</span><span class="sxs-lookup"><span data-stu-id="75a7f-121">$$0\equiv \begin{bmatrix} 1 \\\\  0 \end{bmatrix}, \qquad 1 \equiv \begin{bmatrix} 0 \\\\  1 \end{bmatrix},$$</span></span>

<span data-ttu-id="75a7f-122">尽管相反的选择也可以更好地执行。</span><span class="sxs-lookup"><span data-stu-id="75a7f-122">although the opposite choice could equally well be taken.</span></span> <span data-ttu-id="75a7f-123">因此，在可能的单 qubit 量程状态向量外，只有两个对应于传统位的状态;所有其他量程状态都不是。</span><span class="sxs-lookup"><span data-stu-id="75a7f-123">Thus, out of the infinite number of possible single-qubit quantum state vectors, only two correspond to states of classical bits; all other quantum states do not.</span></span>

## <a name="measuring-a-qubit"></a><span data-ttu-id="75a7f-124">测量 Qubit</span><span class="sxs-lookup"><span data-stu-id="75a7f-124">Measuring a Qubit</span></span>

<span data-ttu-id="75a7f-125">现在，我们知道了如何表示 qubit，我们可以通过讨论[*度量*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics)概念来获取这些状态所表示内容的一些直觉。</span><span class="sxs-lookup"><span data-stu-id="75a7f-125">Now that we know how to represent a qubit, we can gain some intuition for what these states represent by discussing the concept of [*measurement*](https://en.wikipedia.org/wiki/Measurement_in_quantum_mechanics).</span></span> <span data-ttu-id="75a7f-126">度量值对应于 "查找" qubit 的非正式构想，这会立即将量程状态折叠为两个经典状态 $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $ 或 $ \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $ 中的一个。</span><span class="sxs-lookup"><span data-stu-id="75a7f-126">A measurement corresponds to the informal idea of “looking” at a qubit, which immediately collapses the quantum state to one of the two classical states  $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$ or  $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="75a7f-127">当计量状态向量 $ \begin{bmatrix} \alpha \beta \end{bmatrix} $ 指定的 qubit 时 \\ \\ ，我们将获得结果 $0 $ with probability $ | \alpha | ^ 2 $ 和结果 $1 $ with probability $ | \beta | ^ 2 $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-127">When a qubit given by the quantum state vector  $\begin{bmatrix} \alpha \\\\  \beta \end{bmatrix}$ is measured, we obtain the outcome $0$ with probability $|\alpha|^2$ and the outcome $1$  with probability $|\beta|^2$.</span></span> <span data-ttu-id="75a7f-128">在结果 $0 $ 中，qubit 的新状态为 $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $; 在结果 $1 $ 上，其状态为 $ \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-128">On outcome $0$, the qubit's new state is $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$; on outcome $1$ its state is $\begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span> <span data-ttu-id="75a7f-129">请注意，由于规范化条件 $ | \alpha | ^ 2 + | \beta | ^ 2 = $1，这些概率的总和最高为 $1 $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-129">Note that these probabilities sum up to $1$ because of the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.</span></span>

<span data-ttu-id="75a7f-130">度量值的属性也表示量程状态向量的整体符号是不相关的。</span><span class="sxs-lookup"><span data-stu-id="75a7f-130">The properties of measurement also mean that the overall sign of the quantum state vector is irrelevant.</span></span> <span data-ttu-id="75a7f-131">取消矢量等效于 $ \alpha \rightarrow-\alpha $ 和 $ \beta \rightarrow-\beta $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-131">Negating a vector is equivalent to $\alpha \rightarrow -\alpha$ and $\beta \rightarrow -\beta$.</span></span> <span data-ttu-id="75a7f-132">由于度量值 $0 $ 和 $1 $ 的概率取决于术语的大小平方，因此插入此类符号不会改变概率。</span><span class="sxs-lookup"><span data-stu-id="75a7f-132">Because the probability of measuring $0$ and $1$ depends on the magnitude squared of the terms, inserting such signs does not change the probabilities whatsoever.</span></span> <span data-ttu-id="75a7f-133">此类阶段通常称为[ \`\` *全局阶段*""](https://en.wikipedia.org/wiki/Phase_factor) ，更常见的形式为 $e ^ {i \phi} $，而不只是 $ \pm $1。</span><span class="sxs-lookup"><span data-stu-id="75a7f-133">Such phases are commonly called [\`\`*global phases*''](https://en.wikipedia.org/wiki/Phase_factor) and more generally can be of the form $e^{i \phi}$ rather than just $\pm 1$.</span></span>

<span data-ttu-id="75a7f-134">度量值的最后一个重要属性是它不一定损坏所有的量程状态向量。</span><span class="sxs-lookup"><span data-stu-id="75a7f-134">A final important property of measurement is that it does not necessarily damage all quantum state vectors.</span></span> <span data-ttu-id="75a7f-135">如果我们以状态 $ \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} $ （对应于古典状态 $0 $）开头的 qubit，则测量此状态将始终产生结果 $0 $，并使量程状态保持不变。</span><span class="sxs-lookup"><span data-stu-id="75a7f-135">If we start with a qubit in the state $\begin{bmatrix} 1 \\\\  0 \end{bmatrix}$, which corresponds to the classical state $0$, measuring this state will always yield the outcome $0$ and leave the quantum state unchanged.</span></span> <span data-ttu-id="75a7f-136">在这种情况下，如果我们只有传统位（即，qubits 是 $ \begin{bmatrix}1 \\ \\ 0 \end{bmatrix} $ 或 $ \begin{bmatrix}0 \\ \\ 1 \end{bmatrix} $），则测量不会损坏系统。</span><span class="sxs-lookup"><span data-stu-id="75a7f-136">In this sense, if we only have classical bits (i.e., qubits that are either $\begin{bmatrix}1 \\\\  0 \end{bmatrix}$ or $\begin{bmatrix}0 \\\\  1 \end{bmatrix}$) then measurement does not damage the system.</span></span> <span data-ttu-id="75a7f-137">这意味着，我们可以复制传统数据并在量程计算机上对其进行操作，就像在传统计算机上操作一样。</span><span class="sxs-lookup"><span data-stu-id="75a7f-137">This means that we can replicate classical data and manipulate it on a quantum computer just as one could do on a classical computer.</span></span> <span data-ttu-id="75a7f-138">不过，同时将信息同时存储在这两个状态中的能力，就是将量程计算作为可能的经典以及进一步剥夺的量程计算能力，从而无法以无顺序复制量程数据，另请参阅[无克隆定理](https://en.wikipedia.org/wiki/No-cloning_theorem)。</span><span class="sxs-lookup"><span data-stu-id="75a7f-138">The ability, however, to store information in both states at once is what elevates quantum computing beyond what is possible classically and further robs quantum computers of the ability to copy quantum data indiscriminately, see also [the no-cloning theorem](https://en.wikipedia.org/wiki/No-cloning_theorem).</span></span>

## <a name="visualizing-qubits-and-transformations-using-the-bloch-sphere"></a><span data-ttu-id="75a7f-139">使用 Bloch 球可视化 Qubits 和转换</span><span class="sxs-lookup"><span data-stu-id="75a7f-139">Visualizing Qubits and Transformations using the Bloch Sphere</span></span>

<span data-ttu-id="75a7f-140">Qubits 还可以使用[*Bloch 球*](https://en.wikipedia.org/wiki/Bloch_sphere)表示形式在 $ 3 $ D 中进行图片。</span><span class="sxs-lookup"><span data-stu-id="75a7f-140">Qubits may also be pictured in $3$D using the [*Bloch sphere*](https://en.wikipedia.org/wiki/Bloch_sphere) representation.</span></span>  <span data-ttu-id="75a7f-141">Bloch 球体提供一种方法，用于将 qubit 量程状态（这是一种二维复杂向量）描述为三维实值矢量。</span><span class="sxs-lookup"><span data-stu-id="75a7f-141">The Bloch sphere gives a way of describing a single-qubit quantum state (which is a two-dimensional complex vector) as a three-dimensional real-valued vector.</span></span>  <span data-ttu-id="75a7f-142">这一点很重要，因为它使我们能够直观显示单 qubit 状态，从而提高了了解多 qubit 状态（不幸的 Bloch 球表示法中断）的。</span><span class="sxs-lookup"><span data-stu-id="75a7f-142">This is important because it allows us to visualize single-qubit states and thereby develop reasoning that can be invaluable in understanding multi-qubit states (where sadly the Bloch sphere representation breaks down).</span></span>  <span data-ttu-id="75a7f-143">可按如下所示可视化 Bloch 球：</span><span class="sxs-lookup"><span data-stu-id="75a7f-143">The Bloch sphere can be visualized as follows:</span></span>

<!--- ![](.\media\bloch.svg){ width=50% } --->
<span data-ttu-id="75a7f-144">![Bloch 球体](~/media/concepts_bloch.png)</span><span class="sxs-lookup"><span data-stu-id="75a7f-144">![Bloch sphere](~/media/concepts_bloch.png)</span></span>

<span data-ttu-id="75a7f-145">此图中的箭头显示了量程状态向量指向的方向，每次箭头转换都可以被视为一种基数轴的旋转。</span><span class="sxs-lookup"><span data-stu-id="75a7f-145">The arrows in this diagram show the direction in which the quantum state vector is pointing and each transformation of the arrow can be thought of as a rotation about one of the cardinal axes.</span></span>
<span data-ttu-id="75a7f-146">尽管将一系列循环计算视为一系列强大的直觉，但使用此直觉来设计和描述算法非常困难。</span><span class="sxs-lookup"><span data-stu-id="75a7f-146">While thinking about a quantum computation as a sequence of rotations is a powerful intuition, it is challenging to use this intuition to design and describe algorithms.</span></span> <span data-ttu-id="75a7f-147">问：通过提供一种用于描述此类旋转的语言来缓解此问题。</span><span class="sxs-lookup"><span data-stu-id="75a7f-147">Q# alleviates this issue by providing a language for describing such rotations.</span></span>

## <a name="single-qubit-operations"></a><span data-ttu-id="75a7f-148">单 Qubit 操作</span><span class="sxs-lookup"><span data-stu-id="75a7f-148">Single-Qubit Operations</span></span>

<span data-ttu-id="75a7f-149">量程计算机通过应用一组可以模拟量子状态向量旋转的通用量子入口来处理数据。</span><span class="sxs-lookup"><span data-stu-id="75a7f-149">Quantum computers process data by applying a universal set of quantum gates that can emulate any rotation of the quantum state vector.</span></span>
<span data-ttu-id="75a7f-150">这种通用性的概念类似于传统（即传统）计算的通用性概念，如果输入位的每个转换都可以使用有限长度线路执行，则将门集视为通用。</span><span class="sxs-lookup"><span data-stu-id="75a7f-150">This notion of universality is akin to the notion of universality for traditional (i.e., classical) computing where a gate set is considered to be universal if every transformation of the input bits can be performed using a finite length circuit.</span></span>
<span data-ttu-id="75a7f-151">在量程计算中，允许在 qubit 上执行的有效转换是单一转换和度量。</span><span class="sxs-lookup"><span data-stu-id="75a7f-151">In quantum computing, the valid transformations that we are allowed to perform on a qubit are unitary transformations and measurement.</span></span>
<span data-ttu-id="75a7f-152">*Adjoint 操作*或复杂的共轭转置对量程计算至关重要，因为需要对量程转换进行反转。</span><span class="sxs-lookup"><span data-stu-id="75a7f-152">The *adjoint operation* or the complex conjugate transpose is of crucial importance to quantum computing because it is needed to invert quantum transformations.</span></span>
<span data-ttu-id="75a7f-153">Q # 通过提供自动将入口序列编译到 adjoint 的方法来反映这一点，这使程序员在许多情况下都必须 adjoints 代码。</span><span class="sxs-lookup"><span data-stu-id="75a7f-153">Q# reflects this by providing methods to automatically compile gate sequences to their adjoint, which saves the programmer from having to hand code adjoints in many cases.</span></span> <span data-ttu-id="75a7f-154">下面显示了一个示例：</span><span class="sxs-lookup"><span data-stu-id="75a7f-154">An example of this is shown below:</span></span>

```qsharp
operation PrepareSuperposition(qubit : Qubit) : Unit
is Adj { // Auto-generate the adjoint of the operation
    H(qubit);
}
```

<span data-ttu-id="75a7f-155">尽管这是一个简单的示例（因为此 <xref:microsoft.quantum.intrinsic.h> 操作是自我 adjoint 的），因此，你可以了解对于更复杂的 qubit 操作，这一点非常有用。</span><span class="sxs-lookup"><span data-stu-id="75a7f-155">Although this is a trivial example (as the <xref:microsoft.quantum.intrinsic.h> operation is self-adjoint), you can see how this becomes invaluable for more complicated qubit operations.</span></span>
<span data-ttu-id="75a7f-156">有关详细信息，请参阅[操作和函数](xref:microsoft.quantum.guide.operationsfunctions)。</span><span class="sxs-lookup"><span data-stu-id="75a7f-156">For more information, see [Operations and Functions](xref:microsoft.quantum.guide.operationsfunctions).</span></span>

<span data-ttu-id="75a7f-157">传统计算机上只有四个可将一个位映射到一位的函数。</span><span class="sxs-lookup"><span data-stu-id="75a7f-157">There are only four functions that map one bit to one bit on a classical computer.</span></span> <span data-ttu-id="75a7f-158">与此相反，在一个量程计算机上的单个 qubit 上存在无限数量的单一转换。</span><span class="sxs-lookup"><span data-stu-id="75a7f-158">In contrast, there are an infinite number of unitary transformations on a single qubit on a quantum computer.</span></span> <span data-ttu-id="75a7f-159">因此，一组有限的基元量程操作（称为[*入口*](https://en.wikipedia.org/wiki/Quantum_logic_gate)）可以精确地复制量子计算中允许的无限单一转换集。</span><span class="sxs-lookup"><span data-stu-id="75a7f-159">Therefore, no finite set of primitive quantum operations, called [*gates*](https://en.wikipedia.org/wiki/Quantum_logic_gate), can exactly replicate the infinite set of unitary transformations allowed in quantum computing.</span></span> <span data-ttu-id="75a7f-160">这意味着，与传统计算不同，量程计算机可能会完全使用有限数量的入口来实现每个可能的量程计划。</span><span class="sxs-lookup"><span data-stu-id="75a7f-160">This means, unlike classical computing, it is impossible for a quantum computer to implement every possible quantum program exactly using a finite number of gates.</span></span> <span data-ttu-id="75a7f-161">因此，在传统计算机上，量程计算机不能是通用的。</span><span class="sxs-lookup"><span data-stu-id="75a7f-161">Thus quantum computers cannot be universal in the same sense of classical computers.</span></span> <span data-ttu-id="75a7f-162">因此，当我们说一组入口对量程计算是*通用*的时，我们实际上意味着比传统计算略有不同。</span><span class="sxs-lookup"><span data-stu-id="75a7f-162">As a result, when we say that a set of gates is *universal* for quantum computing we actually mean something slightly weaker than we mean with classical computing.</span></span>
<span data-ttu-id="75a7f-163">对于通用性，我们要求量程计算机仅在使用有限长度入口序列的有限错误内*估算*每个单一矩阵。</span><span class="sxs-lookup"><span data-stu-id="75a7f-163">For universality, we require that a quantum computer only *approximate* every unitary matrix within a finite error using a finite length gate sequence.</span></span>
<span data-ttu-id="75a7f-164">换句话说，如果任何单一转换都可以大致作为此集的入口产品写入，则可以使用一组入口。</span><span class="sxs-lookup"><span data-stu-id="75a7f-164">In other words, a set of gates is a universal gate set if any unitary transformation can be approximately written as a product of gates from this set.</span></span> <span data-ttu-id="75a7f-165">对于任何规定的错误，我们都需要，入口集中存在 $G _ {1} ，G_ {2} ，\ldots，G_N $ 的入口，这样</span><span class="sxs-lookup"><span data-stu-id="75a7f-165">We require that for any prescribed error bound, there exist gates $G_{1}, G_{2},\ldots, G_N$ from the gate set such that</span></span>

<span data-ttu-id="75a7f-166">$ $ G_N G_ {N-1} \cdots G_2 G_1 \approx U. $ $</span><span class="sxs-lookup"><span data-stu-id="75a7f-166">$$ G_N G_{N-1} \cdots G_2 G_1 \approx U. $$</span></span>

<span data-ttu-id="75a7f-167">请注意，因为矩阵乘法的约定是从右到左进行相乘，所以 $G _N $，实际上是最后一个应用于量程状态向量的操作。</span><span class="sxs-lookup"><span data-stu-id="75a7f-167">Note that because the convention for matrix multiplication is to multiply from right to left the first gate operation in this sequence, $G_N$, is actually the last one applied to the quantum state vector.</span></span> <span data-ttu-id="75a7f-168">更正式地说，如果每个容错 $ \epsilon>$0 存在 $G _1、\ldots G_N $，则此类门集是通用的，$，$G _N G_1 $ 和 $U $ 之间的距离最多可为 $ \epsilon $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-168">More formally, we say that such a gate set is universal if for every error tolerance $\epsilon>0$ there exists $G_1,\ldots, G_N$ such that  the distance between $G_N\ldots G_1$ and $U$ is at most $\epsilon$.</span></span> <span data-ttu-id="75a7f-169">理想情况下，若要达到 $ \epsilon $ 的这一距离，需要的值 $N $ 应缩放 poly-对数 $ 1/\ epsilon $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-169">Ideally the value of $N$ needed to reach this distance of $\epsilon$ should scale poly-logarithmically with $1/\epsilon$.</span></span>

<span data-ttu-id="75a7f-170">这种通用的入口集在实践中是什么样子？</span><span class="sxs-lookup"><span data-stu-id="75a7f-170">What does such a universal gate set look like in practice?</span></span>  <span data-ttu-id="75a7f-171">最简单的 qubit 入口集通用入口集仅包含两个入口： Hadamard 门 $H $ 和所谓的 $T $-入口（也称为 $ \ pi/8 $ 门）：</span><span class="sxs-lookup"><span data-stu-id="75a7f-171">The simplest such universal gate set for single-qubit gates consists of only two gates: the Hadamard gate $H$ and the so-called $T$-gate (also known as the $\pi/8$ gate):</span></span>

<span data-ttu-id="75a7f-172">$ $ H = \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ 1 &-1 \end{bmatrix}，\qquad T = \begin{bmatrix} 1 & 0 \\ \\ 0 & e ^ {i \ pi/4} \end{bmatrix}。</span><span class="sxs-lookup"><span data-stu-id="75a7f-172">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix},\qquad T=\begin{bmatrix} 1 & 0 \\\\  0 & e^{i\pi/4} \end{bmatrix}.</span></span>
$$

<span data-ttu-id="75a7f-173">然而，出于与量程误差更正相关的实际原因，更方便的方法是考虑更大的门集，即可以使用 $H $ 和 $T $ 生成的门集。</span><span class="sxs-lookup"><span data-stu-id="75a7f-173">However, for practical reasons related to quantum error correction it can be more convenient to consider a larger gate set, namely one that can be generated using $H$ and $T$.</span></span>
<span data-ttu-id="75a7f-174">我们可以将量程入口分为两类： Clifford 入口和 $T $-入口。</span><span class="sxs-lookup"><span data-stu-id="75a7f-174">We can classify the quantum gates into two categories: Clifford gates and the $T$-gate.</span></span>
<span data-ttu-id="75a7f-175">这种划分非常有用，因为在许多量程错误更正方案中，所谓的 Clifford 入口非常易于实现，这就是在操作和 qubits 实现故障 tolerantly 时，它们只需要很少的资源，而非 Clifford 的入口在需要容错时非常昂贵。</span><span class="sxs-lookup"><span data-stu-id="75a7f-175">This subdivision is useful because in many quantum error correction schemes the so-called Clifford gates are easy to implement, that is they require very few resources in terms of operations and qubits to implement fault tolerantly, whereas non-Clifford gates are quite costly when requiring fault tolerance.</span></span> <span data-ttu-id="75a7f-176">Qubit Clifford 入口的标准集，[默认情况下包含在 Q # 中](xref:microsoft.quantum.libraries.standard.prelude)，包括</span><span class="sxs-lookup"><span data-stu-id="75a7f-176">The standard set of single-qubit Clifford gates, [included by default in Q#](xref:microsoft.quantum.libraries.standard.prelude), include</span></span>

<span data-ttu-id="75a7f-177">$ $ H = \frac {1} {\sqrt {2} } \begin{bmatrix} 1 & 1 \\ \\ 1 &-1 \end{bmatrix}，\qquad S = \begin{bmatrix} 1 & 0 \\ \\ 0 & i \end{bmatrix} = T ^ 2，\qquad X = \begin{bmatrix} 0 &1 \\ \\ 1& 0 \end{bmatrix} = HT ^ 4H，$ $</span><span class="sxs-lookup"><span data-stu-id="75a7f-177">$$ H=\frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\\\  1 &-1  \end{bmatrix} ,\qquad S =\begin{bmatrix} 1 & 0 \\\\  0 & i \end{bmatrix}= T^2,\qquad X=\begin{bmatrix} 0 &1 \\\\  1& 0 \end{bmatrix}= HT^4H, $$</span></span>

<span data-ttu-id="75a7f-178">$ $ Y = \begin{bmatrix} 0 &-i \\ \\ & 0 \End{bmatrix} = T ^ 2HT ^ 4 HT ^ 6，\qquad Z = \begin{bmatrix}1&0 \\ \\ 0&-1 \end{bmatrix} = T ^ 4。</span><span class="sxs-lookup"><span data-stu-id="75a7f-178">$$ Y = \begin{bmatrix} 0 & -i \\\\  i & 0 \end{bmatrix}=T^2HT^4  HT^6, \qquad Z=\begin{bmatrix}1&0\\\\ 0&-1 \end{bmatrix}=T^4.</span></span>
$$

<span data-ttu-id="75a7f-179">此处 $X $、$Y $ 和 $Z $ 的操作特别频繁使用，并在其 creator Wolfgang Pauli 后命名为[*Pauli 运算符*](https://en.wikipedia.org/wiki/Pauli_matrices)。</span><span class="sxs-lookup"><span data-stu-id="75a7f-179">Here the operations $X$, $Y$ and $Z$ are used especially frequently and are named [*Pauli operators*](https://en.wikipedia.org/wiki/Pauli_matrices) after their creator Wolfgang Pauli.</span></span>
<span data-ttu-id="75a7f-180">与非 Clifford 入口（$T $-入口）结合使用时，可以编写这些操作来估算单个 qubit 上的任何单一转换。</span><span class="sxs-lookup"><span data-stu-id="75a7f-180">Together with the non-Clifford gate (the $T$-gate), these operations can be composed to approximate any unitary transformation on a single qubit.</span></span>

<span data-ttu-id="75a7f-181">有关这些操作的详细信息，请参阅其 Bloch 球表示和 Q # 实现，请参阅[内部操作和函数](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions)。</span><span class="sxs-lookup"><span data-stu-id="75a7f-181">For more information on these operations, their Bloch sphere representations and Q# implementations, see [Intrinsic Operations and Functions](xref:microsoft.quantum.libraries.standard.prelude#intrinsic-operations-and-functions).</span></span>

<span data-ttu-id="75a7f-182">作为从这些基元构建单一转换的示例，上面的 Bloch 球体中所示的三个转换对应于门序列 $ \begin{bmatrix} 1 \\ \\ 0 \END{BMATRIX} \mapsto HZH \begin{bmatrix} 1 \\ \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ \\ 1 \end{bmatrix} $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-182">As an example of how unitary transformations can be built from these primitives, the three transformations pictured in the Bloch spheres above correspond to the gate sequence $\begin{bmatrix} 1 \\\\  0 \end{bmatrix} \mapsto HZH \begin{bmatrix} 1 \\\\  0 \end{bmatrix} = \begin{bmatrix} 0 \\\\  1 \end{bmatrix}$.</span></span>

<span data-ttu-id="75a7f-183">虽然上一个构成了用于描述堆栈的逻辑级别上的操作的最常用的基元入口（将逻辑级别视为量程算法的级别），但在算法级别更少的基本操作（例如，操作更接近函数说明级别）通常是很方便的。</span><span class="sxs-lookup"><span data-stu-id="75a7f-183">While the previous constitute the most popular primitive gates for describing operations on the logical level of the stack (think of the logical level as the level of the quantum algorithm), it is often convenient to consider less basic operations at the algorithmic level, for example operations closer to a function description level.</span></span> <span data-ttu-id="75a7f-184">幸运的是，Q # 还提供了可用于实现更高级别的 unitaries 的方法，这进而允许实现高级算法，而无需将所有内容明确分解到 Clifford 并 $T $-入口。</span><span class="sxs-lookup"><span data-stu-id="75a7f-184">Fortunately, Q# also has methods available for implementing higher-level unitaries, which in turn allow high-level algorithms to be implemented without explicitly decomposing everything down to Clifford and $T$-gates.</span></span>

<span data-ttu-id="75a7f-185">最简单的此类基元是单个 qubit 旋转。</span><span class="sxs-lookup"><span data-stu-id="75a7f-185">The simplest such primitive is the single qubit-rotation.</span></span> <span data-ttu-id="75a7f-186">通常会考虑三种单 qubit 旋转： $R _x $、$R _y $ 和 $R _z $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-186">Three single-qubit rotations are typically considered: $R_x$, $R_y$ and $R_z$.</span></span> <span data-ttu-id="75a7f-187">例如，若要可视化旋转 $R _x （\theta） $ 的操作，请在 Bloch 球的 $x $ 轴方向上按下向右的拇指，并通过 $ \ theta/2 $ 弧度角度旋转矢量。</span><span class="sxs-lookup"><span data-stu-id="75a7f-187">To visualize the action of the rotation $R_x(\theta)$, for example, imagine pointing your right thumb along the direction of the $x$-axis of the Bloch sphere and rotating the vector with your hand through an angle of $\theta/2$ radians.</span></span> <span data-ttu-id="75a7f-188">这是 $2 $ 的令人困惑的因素，这是因为正如在 Bloch 球上绘制时，正向矢量 \circ $</span><span class="sxs-lookup"><span data-stu-id="75a7f-188">This confusing factor of $2$ arises from the fact that orthogonal vectors are $180^\circ$ apart when plotted on the Bloch sphere, yet are actually $90^\circ$ degrees apart geometrically.</span></span> <span data-ttu-id="75a7f-189">对应的单一矩阵包括：</span><span class="sxs-lookup"><span data-stu-id="75a7f-189">The corresponding unitary matrices are:</span></span>

<span data-ttu-id="75a7f-190">\begin{align *} &R_z （\theta） = e ^ {-I\theta z/2} = \begin{bmatrix} e ^ {-i \ theta/2} & 0 \\ \\ 0& e ^ {i \ theta/2} \end{bmatrix}， \\ \\ &R_x （\theta） = e ^ {-i\theta x/2} = HR_z （\theta） H = \begin{bmatrix} \cos （\ theta/2） &-i\sin （\ theta/2）-i\sin （\ theta/2） \cos \end{bmatrix} \\ \\ & &\\ \\ R_y （\Theta） = e ^ {-i\theta y/2} = SHR_z （\theta） HS ^ \dagger = \begin{bmatrix} \cos （\ theta/2） &-\sin （\ theta/2） \sin \\ \\ （\ theta/* 2） \cos \end{bmatrix}. &</span><span class="sxs-lookup"><span data-stu-id="75a7f-190">\begin{align *} &R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0\\\\  0& e^{i\theta/2} \end{bmatrix}, \\\\ &R_x(\theta) = e^{-i\theta X/2} = HR_z(\theta)H = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2)\\\\  -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix}, \\\\ &R_y(\theta) = e^{-i\theta Y/2} = SHR_z(\theta)HS^\dagger = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2)\\\\  \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}. \end{align*}</span></span>

<span data-ttu-id="75a7f-191">正如可以将任何三个旋转组合在一起以在三个维度中执行任意旋转一样，可以从 Bloch 的球表示来看，可以将任何单一的矩阵作为三个旋转序列来编写。</span><span class="sxs-lookup"><span data-stu-id="75a7f-191">Just as any three rotations can be combined together to perform an arbitrary rotation in three dimensions, it can be seen from the Bloch sphere representation that any unitary matrix can be written as a sequence of three rotations as well.</span></span> <span data-ttu-id="75a7f-192">具体而言，对于每个单一矩阵 $U $ 存在 $ \alpha、\beta、\gamma、\delta $，$U = e ^ {i\alpha} R_x （\beta） R_z （\gamma） R_x （\delta） $。</span><span class="sxs-lookup"><span data-stu-id="75a7f-192">Specifically, for every unitary matrix $U$ there exists $\alpha,\beta,\gamma,\delta$ such that $U= e^{i\alpha} R_x(\beta)R_z(\gamma)R_x(\delta)$.</span></span> <span data-ttu-id="75a7f-193">因此 $R _z （\theta） $ 和 $H $ 也形成通用的入口集，尽管 $ \theta $ 可以采用任何值，但它不是离散集。</span><span class="sxs-lookup"><span data-stu-id="75a7f-193">Thus $R_z(\theta)$ and $H$ also form a universal gate set although it is not a discrete set because $\theta$ can take any value.</span></span> <span data-ttu-id="75a7f-194">出于此原因，和由于量程模拟中的应用程序，此类连续入口对量程计算至关重要，尤其是在量程算法设计级别。</span><span class="sxs-lookup"><span data-stu-id="75a7f-194">For this reason, and due to applications in quantum simulation, such continuous gates are crucial for quantum computation, especially at the quantum algorithm design level.</span></span> <span data-ttu-id="75a7f-195">为了实现容错硬件实现，最终将其编译为与这些旋转紧密相关的离散入口序列。</span><span class="sxs-lookup"><span data-stu-id="75a7f-195">To achieve fault-tolerant hardware implementation, they will ultimately be compiled into discrete gate sequences that closely approximate these rotations.</span></span>
