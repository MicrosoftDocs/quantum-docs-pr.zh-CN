---
title: 软件堆栈 |Microsoft Docs
description: 软件堆栈
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184723"
---
# <a name="software-stack-for-quantum-computing"></a>用于量程计算的软件堆栈
通常，当我们想象到一台计算机上，我们设想一个运行应用程序的设备，但新式计算环境则更加复杂和高级。 我们与之交互的应用程序通常位于多个软件层上，使应用程序的执行向下到硬件级别。 这些软件层是从完整计算系统的底层复杂性抽象应用程序解决方案的开发所必需的。 如果开发人员在编写简单的智能手机应用程序时必须考虑总线、缓存体系结构、通信协议等，则任务会变得更加复杂。  *软件堆栈*的概念是在传统计算中开发的，用于解决这些问题。  从传统概念中借用，软件堆栈也是使用 Q # 的量程计算的主要部分。

## <a name="conventional-stack"></a>传统堆栈
软件堆栈背后的关键理念是 "递归"。  它包含多个嵌套的接口层，这些接口抽象于开发人员的更低级别的详细信息。  例如，常用的软件堆栈包括在 SQL server （关系数据库管理系统）之上运行 ASP.NET （一种编程语言），该程序在 Windows server 顶层运行的 Internet Information Services （一种 web 服务器）上运行（操作系统）来驱动计算机硬件。  通过查看软件作为层次结构，可以在 ASP.NET 中编写软件，而无需了解低于它的所有软件的低级别详细信息。

## <a name="quantum-stack"></a>量程堆栈

量程计算中的软件堆栈并不相同，实际上在比传统堆栈更低的级别进行操作。  量程堆栈看起来是什么样子？  量程计算机不能替代传统（通常称为传统）计算机。  事实上，量程计算机几乎肯定会与传统计算机一起工作以解决计算问题。  在部分中，这是因为量程数据的脆弱性。  量程数据非常脆弱，如果你甚至查看它，几乎肯定会损坏所观察到的信息。  因此，量程计算机需要在设计时考虑到量程错误更正，以便与物理环境之间的交互交互不会无意中破坏信息和计算。 出于此原因，Q # 的自然目标是一个错误更正的量程计算机（通常*称为容错的量程计算机*），该计算机接受量程指令列表（称为 "入口" 或 "门" 操作）并将这些指令应用于量程其中存储的数据。  请注意，如果量程算法或程序中的 qubits 和入口操作数足够小，则可能不一定要进行错误更正。  但是，随着 qubits 和门操作的增加，这一点肯定是必需的，因此，我们将我们的软件堆栈和 Q # 构建为名称正好并有效处理错误纠正并实现可缩放的容错量子计算。

### <a name="error-correction"></a>错误更正
错误更正需要与量程计算机一起运行快速可靠的传统计算机，以便更正量程计算中出现的错误。  在实践中，某些组件（如现场可编程的入口阵列（Fpga）或 fast cryogenic 处理器）可能需要识别并纠正比在量程计算机上自然累积的错误更快。  因此，量程计算机是一台混合式计算机，其中包含多个不同的计算设备，这些设备在各种温度上运行。  出于此原因，最好是通过软件堆栈的镜头来对量程计算机进行编程，因为最终要实现量程的实现需要许多层的硬件和软件（古典和量子）量程计算机上的算法。

### <a name="quantum-conceptual-stack"></a>量程概念堆栈
下面显示了一个概念堆栈，该堆栈说明了在量程计算环境中因式分解为8704143553785700723的函数流：

![软件堆栈](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a>规范和算法
这种情况有几个广泛的编程阶段，如量程计算。  第一种是最具挑战性的阶段，它指定了要解决的问题。  在这种情况下，问题是将数字8704143553785700723划分为两个质数的乘积。  接下来的步骤涉及设计用于解决此计算问题的算法。  在这种情况下，可以使用选定的著名量程分解算法来找出因素。  此算法用 Q # 表示，然后一系列量程操作是输出，可在理想化的无错误量程计算机上运行。  

### <a name="physical-gates"></a>物理入口
在此示例中，假设性质并不是提供错误的量程计算机，因此，后续步骤将使用由 Q # 发出的操作，并使用选择到物理入口的量程错误纠正方法指定的模板来转换它们。基本硬件可执行。  此过程涉及将上一模型中描述的每个逻辑 qubit 替换为一个物理 qubits 主机，该主机用于以冗余方式存储和保护单个 qubit 中的信息，从而在构成物理qubits 足够长的时间来检测和更正此类错误。  正如 Q # 代码所述的逻辑 qubits 需要替换为多个物理 qubits，同样，输出中所述的每个量程门都需要转换为一系列充当物理 qubits 的物理入口。  出于此原因，Q # 的输出很少是最终的量程计算目标，并且需要进一步的抽象级别以在意的方式在硬件上执行代码。

### <a name="control-computer"></a>控制计算机
然后，将物理入口序列加载到普通计算机，将这些指令向下发送到直接与量子计算机直接交互的控制计算机。  此层通常由实验控制软件（如[QCoDeS](http://qcodes.github.io/Qcodes/)）处理。

### <a name="interface-computer"></a>接口计算机
此过程的最后一步涉及接口计算机首先根据需要将入口流式传输到快速控制计算机。 然后，fast control 计算机应用所需的电压（通常称为脉冲）来实现 qubits 上所需的入口。 此操作必须在更正通过量程错误更正观测到的所有错误时执行。  Cryogenic Fpga 或其他现硬件可能需要在规定的严格时间要求内执行这些步骤，因为在量程计算机上出现错误的速率。  此级别的目标语言通常是[VHDL](https://en.wikipedia.org/wiki/VHDL)，这需要一种不同的方式来考虑它在堆栈的最前端使用，以分析量程算法的说明。

### <a name="the-q-quantum-programming-language"></a>Q # 量程编程语言
Q # 的目标是提供一种简单的语言，使开发人员能够编写针对大量的量程计算平台和接口的代码，这些代码与用户和量程设备之间的插入软件层相结合。  语言通过利用软件堆栈的概念并提取基础量程计算机的许多详细信息，并允许其他级别的堆栈（通过等C#语言公开）执行必要的从 Q # 代码转换为基本操作。  这使开发人员能够专注于它们的最佳效果：设计算法和解决问题。
