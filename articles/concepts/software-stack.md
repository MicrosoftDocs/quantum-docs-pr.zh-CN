---
title: 软件堆栈 |Microsoft Docs
description: 软件堆栈
author: QuantumWriter
uid: microsoft.quantum.concepts.software-stack
ms.author: nawiebe@microsoft.com
ms.date: 12/11/2017
ms.topic: article
ms.openlocfilehash: f97dfacf6cde5fa92e1f368efaae36554a5c944d
ms.sourcegitcommit: 8becfb03eb60ba205c670a634ff4daa8071bcd06
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/28/2019
ms.locfileid: "73184723"
---
# <a name="software-stack-for-quantum-computing"></a><span data-ttu-id="5dda8-103">用于量程计算的软件堆栈</span><span class="sxs-lookup"><span data-stu-id="5dda8-103">Software stack for quantum computing</span></span>
<span data-ttu-id="5dda8-104">通常，当我们想象到一台计算机上，我们设想一个运行应用程序的设备，但新式计算环境则更加复杂和高级。</span><span class="sxs-lookup"><span data-stu-id="5dda8-104">Normally when we think of a computer we envision a single device running an application, but modern computing environments are much more complex and advanced.</span></span> <span data-ttu-id="5dda8-105">我们与之交互的应用程序通常位于多个软件层上，使应用程序的执行向下到硬件级别。</span><span class="sxs-lookup"><span data-stu-id="5dda8-105">The application we interact with typically rests on multiple layers of software that provide for the application's execution down to the hardware level.</span></span> <span data-ttu-id="5dda8-106">这些软件层是从完整计算系统的底层复杂性抽象应用程序解决方案的开发所必需的。</span><span class="sxs-lookup"><span data-stu-id="5dda8-106">These software layers are necessary to abstract the development of an application solution from the underlying complexity of the complete computing system.</span></span> <span data-ttu-id="5dda8-107">如果开发人员在编写简单的智能手机应用程序时必须考虑总线、缓存体系结构、通信协议等，则任务会变得更加复杂。</span><span class="sxs-lookup"><span data-stu-id="5dda8-107">If a developer had to think about bus, cache architectures, communication protocols, and more while writing a simple smartphone app, the task would become much more complex.</span></span>  <span data-ttu-id="5dda8-108">*软件堆栈*的概念是在传统计算中开发的，用于解决这些问题。</span><span class="sxs-lookup"><span data-stu-id="5dda8-108">The concept of a *software stack* was developed in classical computing to address these issues.</span></span>  <span data-ttu-id="5dda8-109">从传统概念中借用，软件堆栈也是使用 Q # 的量程计算的主要部分。</span><span class="sxs-lookup"><span data-stu-id="5dda8-109">Borrowing from the classical concept, a software stack is also a key part of the vision behind quantum computing with Q#.</span></span>

## <a name="conventional-stack"></a><span data-ttu-id="5dda8-110">传统堆栈</span><span class="sxs-lookup"><span data-stu-id="5dda8-110">Conventional stack</span></span>
<span data-ttu-id="5dda8-111">软件堆栈背后的关键理念是 "递归"。</span><span class="sxs-lookup"><span data-stu-id="5dda8-111">The key idea behind a software stack is recursion.</span></span>  <span data-ttu-id="5dda8-112">它包含多个嵌套的接口层，这些接口抽象于开发人员的更低级别的详细信息。</span><span class="sxs-lookup"><span data-stu-id="5dda8-112">It consists of several nested layers of interfaces that abstract the details of the lower levels of the device away from the developer.</span></span>  <span data-ttu-id="5dda8-113">例如，常用的软件堆栈包括在 SQL server （关系数据库管理系统）之上运行 ASP.NET （一种编程语言），该程序在 Windows server 顶层运行的 Internet Information Services （一种 web 服务器）上运行（操作系统）来驱动计算机硬件。</span><span class="sxs-lookup"><span data-stu-id="5dda8-113">For example, a commonly used software stack involves running ASP.NET (a programming language), on top of SQL server (a relational database management system), which runs on top of Internet Information Services (a web server), which runs on top of Windows server (an operating system), which drives the computer hardware.</span></span>  <span data-ttu-id="5dda8-114">通过查看软件作为层次结构，可以在 ASP.NET 中编写软件，而无需了解低于它的所有软件的低级别详细信息。</span><span class="sxs-lookup"><span data-stu-id="5dda8-114">By looking at software as a hierarchy, one can write software in ASP.NET without needing to understand the low-level details of all the software below it.</span></span>

## <a name="quantum-stack"></a><span data-ttu-id="5dda8-115">量程堆栈</span><span class="sxs-lookup"><span data-stu-id="5dda8-115">Quantum stack</span></span>

<span data-ttu-id="5dda8-116">量程计算中的软件堆栈并不相同，实际上在比传统堆栈更低的级别进行操作。</span><span class="sxs-lookup"><span data-stu-id="5dda8-116">The software stack in quantum computing is no different in principle, and in practice operates at a lower level than traditional stacks.</span></span>  <span data-ttu-id="5dda8-117">量程堆栈看起来是什么样子？</span><span class="sxs-lookup"><span data-stu-id="5dda8-117">What does a quantum stack look like?</span></span>  <span data-ttu-id="5dda8-118">量程计算机不能替代传统（通常称为传统）计算机。</span><span class="sxs-lookup"><span data-stu-id="5dda8-118">A quantum computer is not a replacement for traditional (often called classical) computers.</span></span>  <span data-ttu-id="5dda8-119">事实上，量程计算机几乎肯定会与传统计算机一起工作以解决计算问题。</span><span class="sxs-lookup"><span data-stu-id="5dda8-119">In fact, quantum computers will almost certainly work in tandem with classical computers to solve computational problems.</span></span>  <span data-ttu-id="5dda8-120">在部分中，这是因为量程数据的脆弱性。</span><span class="sxs-lookup"><span data-stu-id="5dda8-120">In part, this arises because of the fragility of quantum data.</span></span>  <span data-ttu-id="5dda8-121">量程数据非常脆弱，如果你甚至查看它，几乎肯定会损坏所观察到的信息。</span><span class="sxs-lookup"><span data-stu-id="5dda8-121">Quantum data is so fragile that if you even look at it you almost certainly damage the information being observed.</span></span>  <span data-ttu-id="5dda8-122">因此，量程计算机需要在设计时考虑到量程错误更正，以便与物理环境之间的交互交互不会无意中破坏信息和计算。</span><span class="sxs-lookup"><span data-stu-id="5dda8-122">Quantum computers will thus need to be designed with quantum error correction in mind so that stray interactions from its physical environment do not inadvertently damage the information and computation.</span></span> <span data-ttu-id="5dda8-123">出于此原因，Q # 的自然目标是一个错误更正的量程计算机（通常*称为容错的量程计算机*），该计算机接受量程指令列表（称为 "入口" 或 "门" 操作）并将这些指令应用于量程其中存储的数据。</span><span class="sxs-lookup"><span data-stu-id="5dda8-123">For this reason, a natural target for Q# is an error-corrected quantum computer (often called a *fault-tolerant* quantum computer) that accepts a list of quantum instructions (called gates or gate operations) and applies those instructions to the quantum data stored within it.</span></span>  <span data-ttu-id="5dda8-124">请注意，如果量程算法或程序中的 qubits 和入口操作数足够小，则可能不一定要进行错误更正。</span><span class="sxs-lookup"><span data-stu-id="5dda8-124">Note that if the number of qubits and gate operations in a quantum algorithm or program is small enough, error correction may not be absolutely necessary.</span></span>  <span data-ttu-id="5dda8-125">但是，随着 qubits 和门操作的增加，这一点肯定是必需的，因此，我们将我们的软件堆栈和 Q # 构建为名称正好并有效处理错误纠正并实现可缩放的容错量子计算。</span><span class="sxs-lookup"><span data-stu-id="5dda8-125">However as the number of qubits and gate operations grow, it will more certainly be a requirement, thus we architect our software stack and Q# to aptly and efficiently handle error correction and enable scalable, fault-tolerant quantum computing.</span></span>

### <a name="error-correction"></a><span data-ttu-id="5dda8-126">错误更正</span><span class="sxs-lookup"><span data-stu-id="5dda8-126">Error correction</span></span>
<span data-ttu-id="5dda8-127">错误更正需要与量程计算机一起运行快速可靠的传统计算机，以便更正量程计算中出现的错误。</span><span class="sxs-lookup"><span data-stu-id="5dda8-127">Error correction requires a fast and reliable classical computer to be run in concert with the quantum computer to correct errors as they appear in the quantum computation.</span></span>  <span data-ttu-id="5dda8-128">在实践中，某些组件（如现场可编程的入口阵列（Fpga）或 fast cryogenic 处理器）可能需要识别并纠正比在量程计算机上自然累积的错误更快。</span><span class="sxs-lookup"><span data-stu-id="5dda8-128">In practice, components such as field-programmable gate arrays (FPGAs) or fast cryogenic processors may be needed to identify and correct the errors faster than they naturally accumulate in the quantum computer.</span></span>  <span data-ttu-id="5dda8-129">因此，量程计算机是一台混合式计算机，其中包含多个不同的计算设备，这些设备在各种温度上运行。</span><span class="sxs-lookup"><span data-stu-id="5dda8-129">As a result, a quantum computer is a hybrid machine comprised of several different computational devices that operate over a wide range of temperatures.</span></span>  <span data-ttu-id="5dda8-130">出于此原因，最好是通过软件堆栈的镜头来对量程计算机进行编程，因为最终要实现量程的实现需要许多层的硬件和软件（古典和量子）量程计算机上的算法。</span><span class="sxs-lookup"><span data-stu-id="5dda8-130">For this reason, it is much more helpful to think about programming a quantum computer through the lens of a software stack, as there are many layers of hardware and software (classical and quantum) required to ultimately achieve the implementation of a quantum algorithm on a quantum computer.</span></span>

### <a name="quantum-conceptual-stack"></a><span data-ttu-id="5dda8-131">量程概念堆栈</span><span class="sxs-lookup"><span data-stu-id="5dda8-131">Quantum conceptual stack</span></span>
<span data-ttu-id="5dda8-132">下面显示了一个概念堆栈，该堆栈说明了在量程计算环境中因式分解为8704143553785700723的函数流：</span><span class="sxs-lookup"><span data-stu-id="5dda8-132">A conceptual stack that illustrates the functional flow of factoring 8704143553785700723 in a quantum computing environment is shown below:</span></span>

![软件堆栈](~/media/concepts_stack.png)

### <a name="specification-and-algorithm"></a><span data-ttu-id="5dda8-134">规范和算法</span><span class="sxs-lookup"><span data-stu-id="5dda8-134">Specification and algorithm</span></span>
<span data-ttu-id="5dda8-135">这种情况有几个广泛的编程阶段，如量程计算。</span><span class="sxs-lookup"><span data-stu-id="5dda8-135">There are several broad stages of programming such a quantum computation.</span></span>  <span data-ttu-id="5dda8-136">第一种是最具挑战性的阶段，它指定了要解决的问题。</span><span class="sxs-lookup"><span data-stu-id="5dda8-136">The first, and arguably most challenging phase, is specifying the problem that one wishes to solve.</span></span>  <span data-ttu-id="5dda8-137">在这种情况下，问题是将数字8704143553785700723划分为两个质数的乘积。</span><span class="sxs-lookup"><span data-stu-id="5dda8-137">In this case, the problem is to factor the number 8704143553785700723  into a product of two prime numbers.</span></span>  <span data-ttu-id="5dda8-138">接下来的步骤涉及设计用于解决此计算问题的算法。</span><span class="sxs-lookup"><span data-stu-id="5dda8-138">The next step involves designing an algorithm for solving this computational problem.</span></span>  <span data-ttu-id="5dda8-139">在这种情况下，可以使用选定的著名量程分解算法来找出因素。</span><span class="sxs-lookup"><span data-stu-id="5dda8-139">In this case, Shor's famous quantum factoring algorithm can be used to find the factors.</span></span>  <span data-ttu-id="5dda8-140">此算法用 Q # 表示，然后一系列量程操作是输出，可在理想化的无错误量程计算机上运行。</span><span class="sxs-lookup"><span data-stu-id="5dda8-140">This algorithm is expressed in Q# and then a sequence of quantum operations is output that could be run on an idealized error-free quantum computer.</span></span>  

### <a name="physical-gates"></a><span data-ttu-id="5dda8-141">物理入口</span><span class="sxs-lookup"><span data-stu-id="5dda8-141">Physical gates</span></span>
<span data-ttu-id="5dda8-142">在此示例中，假设性质并不是提供错误的量程计算机，因此，后续步骤将使用由 Q # 发出的操作，并使用选择到物理入口的量程错误纠正方法指定的模板来转换它们。基本硬件可执行。</span><span class="sxs-lookup"><span data-stu-id="5dda8-142">In this example, assume nature is not so kind as to provide an error-free quantum computer so the subsequent step takes the operations emitted by Q# and translates them using templates specified by the quantum error correction method chosen into physical gates that the basic hardware can execute.</span></span>  <span data-ttu-id="5dda8-143">此过程涉及将上一模型中描述的每个逻辑 qubit 替换为一个物理 qubits 主机，该主机用于以冗余方式存储和保护单个 qubit 中的信息，从而在构成物理qubits 足够长的时间来检测和更正此类错误。</span><span class="sxs-lookup"><span data-stu-id="5dda8-143">This process involves replacing every logical qubit described in the previous model with a host of physical qubits that are used to store and protect the information within a single qubit in a redundant fashion that can resist local errors on the constituent physical qubits long enough for such errors to be detected and corrected.</span></span>  <span data-ttu-id="5dda8-144">正如 Q # 代码所述的逻辑 qubits 需要替换为多个物理 qubits，同样，输出中所述的每个量程门都需要转换为一系列充当物理 qubits 的物理入口。</span><span class="sxs-lookup"><span data-stu-id="5dda8-144">Just as the logical qubits described by the Q# code need to be replaced with many physical qubits, similarly each quantum gate described in the output needs to be translated into a sequence of physical gates that act upon the physical qubits.</span></span>  <span data-ttu-id="5dda8-145">出于此原因，Q # 的输出很少是最终的量程计算目标，并且需要进一步的抽象级别以在意的方式在硬件上执行代码。</span><span class="sxs-lookup"><span data-stu-id="5dda8-145">For this reason, the output of Q# is seldom the final target for quantum computing and further levels of abstraction are needed to execute the code on hardware in an oblivious fashion.</span></span>

### <a name="control-computer"></a><span data-ttu-id="5dda8-146">控制计算机</span><span class="sxs-lookup"><span data-stu-id="5dda8-146">Control computer</span></span>
<span data-ttu-id="5dda8-147">然后，将物理入口序列加载到普通计算机，将这些指令向下发送到直接与量子计算机直接交互的控制计算机。</span><span class="sxs-lookup"><span data-stu-id="5dda8-147">The physical gate sequence is then loaded into an ordinary computer that sends these instructions down to a control computer that interfaces directly with the quantum computer.</span></span>  <span data-ttu-id="5dda8-148">此层通常由实验控制软件（如[QCoDeS](http://qcodes.github.io/Qcodes/)）处理。</span><span class="sxs-lookup"><span data-stu-id="5dda8-148">This layer within the software stack is often handled by experimental control software such as [QCoDeS](http://qcodes.github.io/Qcodes/).</span></span>

### <a name="interface-computer"></a><span data-ttu-id="5dda8-149">接口计算机</span><span class="sxs-lookup"><span data-stu-id="5dda8-149">Interface computer</span></span>
<span data-ttu-id="5dda8-150">此过程的最后一步涉及接口计算机首先根据需要将入口流式传输到快速控制计算机。</span><span class="sxs-lookup"><span data-stu-id="5dda8-150">The final step in this process involves the interface computer first streaming the gates as needed to a fast control computer.</span></span> <span data-ttu-id="5dda8-151">然后，fast control 计算机应用所需的电压（通常称为脉冲）来实现 qubits 上所需的入口。</span><span class="sxs-lookup"><span data-stu-id="5dda8-151">Then the fast control computer applies the voltages needed (commonly called pulses) to implement the required gates on qubits.</span></span> <span data-ttu-id="5dda8-152">此操作必须在更正通过量程错误更正观测到的所有错误时执行。</span><span class="sxs-lookup"><span data-stu-id="5dda8-152">This has to be done while correcting any errors that are observed through quantum error correction.</span></span>  <span data-ttu-id="5dda8-153">Cryogenic Fpga 或其他现硬件可能需要在规定的严格时间要求内执行这些步骤，因为在量程计算机上出现错误的速率。</span><span class="sxs-lookup"><span data-stu-id="5dda8-153">Cryogenic FPGAs or other exotic hardware may be needed to perform these steps within the stringent time requirements imposed by the rate at which errors appear in the quantum computer.</span></span>  <span data-ttu-id="5dda8-154">此级别的目标语言通常是[VHDL](https://en.wikipedia.org/wiki/VHDL)，这需要一种不同的方式来考虑它在堆栈的最前端使用，以分析量程算法的说明。</span><span class="sxs-lookup"><span data-stu-id="5dda8-154">The target language on this level is often [VHDL](https://en.wikipedia.org/wiki/VHDL), which requires a distinct way of thinking from that which is used at the top end of the stack to parse a description of a quantum algorithm.</span></span>

### <a name="the-q-quantum-programming-language"></a><span data-ttu-id="5dda8-155">Q # 量程编程语言</span><span class="sxs-lookup"><span data-stu-id="5dda8-155">The Q# quantum programming language</span></span>
<span data-ttu-id="5dda8-156">Q # 的目标是提供一种简单的语言，使开发人员能够编写针对大量的量程计算平台和接口的代码，这些代码与用户和量程设备之间的插入软件层相结合。</span><span class="sxs-lookup"><span data-stu-id="5dda8-156">The aim of Q# is to provide a simple language that allows developers to write code that targets a wealth of quantum computing platforms and interface with the intervening layers of software that stand between the user and the quantum device.</span></span>  <span data-ttu-id="5dda8-157">语言通过利用软件堆栈的概念并提取基础量程计算机的许多详细信息，并允许其他级别的堆栈（通过等C#语言公开）执行必要的从 Q # 代码转换为基本操作。</span><span class="sxs-lookup"><span data-stu-id="5dda8-157">The language facilitates this by embracing the notion of a software stack and abstracting many of the details of the underlying quantum computer while allowing other levels of the stack, exposed through a language such as C#, to perform the necessary translations from Q# code to fundamental operations.</span></span>  <span data-ttu-id="5dda8-158">这使开发人员能够专注于它们的最佳效果：设计算法和解决问题。</span><span class="sxs-lookup"><span data-stu-id="5dda8-158">This allows the developer to focus on what they do best: designing algorithms and solving problems.</span></span>
