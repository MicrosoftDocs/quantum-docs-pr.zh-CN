---
title: QDK 0.3 语言检查和迁移指南
author: beheim
uid: microsoft.quantum.relnotes.migration-0-3
ms.author: bettina.heim@microsoft.com
ms.date: 10/29/2018
ms.topic: article
ms.openlocfilehash: 6c19f31970ff5440432c5bb3d00e6a7d0eba1e80
ms.sourcegitcommit: aa5e6f4a2deb4271a333d3f1b1eb69b5bb9a7bad
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/02/2019
ms.locfileid: "73442184"
---
# <a name="qdk-03-language-release-notes-and-migration-guide"></a>QDK 0.3 语言发行说明和迁移指南

我们非常高兴地介绍了量子开发工具包的最新更新。  此页概述了新的 Q # 语言功能，并介绍了如何将现有的 Q # 程序[迁移](#Migration)到新的语法。  请参阅[此处](xref:microsoft.quantum.language.intro)完整的 Q # 语言说明文档。


## <a name="whats-new"></a>新功能 

0\.3 更新附带了一系列新语言和编辑器功能。

### <a name="overview-of-features"></a>功能概述

- 增强了 Visual Studio 和 Visual Studio Code 的开发工具集成，其中包括：
    - 实时编译和有关键入的反馈（*也称为* 波浪下划线）。
    - 悬停信息，包括文档摘要和类型签名。
    - 支持 "切换到" 定义。
    - 易于导航到命名空间、操作、函数和类型声明。
    - 改进了诊断消息。
- 语言改进
    - 使用和借款中的单个 qubit 和元组初始化
    - 所有分配的元组析构
    - 数组迭代
    - 条件表达式
    - 默认-操作的专用化缩写
    - 自动生成的类型构造函数
    - 表达式修饰符


## <a name="editor-features"></a>编辑器功能

量程开发工具包现在包含用于 Q # 的语言服务器，以及用于 Visual Studio 和 Visual Studio Code 的客户端集成。
这会启用一组新的 IntelliSense 功能，以及在键入时以波浪下划线的形式发出错误和警告的实时反馈。
具体而言，"跳到定义" 现在受支持，并且显示了悬停信息，其中包含类型信息以及来自记录注释的信息。 此外，还提供了有关定义的命名空间、操作、函数和类型的符号信息，并允许快速导航到声明。    
总体上看，此更新极大地改善了诊断消息，可以轻松地导航到诊断消息的准确范围，并在显示的悬停信息中提供更多详细信息。 

对于此0.3 版本，量子开发工具包附带的语言服务器不支持多个工作区。
若要在 VS Code 中使用项目，请打开包含项目本身的根文件夹和所有引用的项目。
若要在 Visual Studio 中处理解决方案，解决方案中包含的所有项目都需要位于解决方案所在的同一文件夹中，或位于其中一个子文件夹中。

## <a name="language-features"></a>语言功能

就语言功能而言，此更新将对一系列语言模式进行统一处理。
例如，为每个用户定义的类型生成类型构造函数，并且该类型构造函数的应用与任何其他函数相同。
另一个示例是元组析构，它现在完全支持所有分配。 这不仅包括 let、可变和集语句，还包括 for 循环中的迭代变量以及使用-和借款分配。 另外，0.3 更新新支持部分 deconstructions;deconstructions 中的下划线指示要忽略的值的部分。 

下面的代码演示了一些新功能：
```qsharp
    let tuples = [(1, 0), (0, 1)];
    mutable res = (0, 0, 0);

    // For-loops can iterate over arrays, and can destructure tuples.
    for ((i1, i2) in tuples) {

        // Mutable assignments can now destructure and ignore parts of tuples,
        // using the same syntax as let-bindings.
        mutable (r1, r2, _) = res;
        set (r1, r2) = (r1 ||| i1, r2 &&& i2);

        let (_, _, s) = res;
        // The new conditional operator can be used inside expressions, avoiding
        // the need for extraneous if-statements.
        set res = (r1, r2, r1 == r2 ? s | s + 1);
    }
```
最后一个 set 语句使用新的三元运算符，该运算符随0.3 更新引入，以支持条件表达式。
条件表达式是 `condition ? caseTrue | caseFalse`形式的表达式。
正如上面的示例所示，现在还支持对数组进行迭代。

`using` 和 `borrowing` 中的分配是新适用于单个 qubits、qubit 数组和嵌套元组的新的：
```qsharp
    using (q = Qubit()) {
        // q contains a single qubit
    }

    borrowing ((cs, q) = (Qubit[3], Qubit())) {
        // cs contains an array of three qubits, and q contains a single qubit
    }
```

除了引入 `auto` 外，还引入了两个新的特殊化生成器指令 `invert` 和 `distribute` 以提高控制生成函子专用化的方式。
在操作中的默认 `body` 特殊化的显式声明不再是必需的。
与函数类似，如果不在操作中声明其他专用化，则语句可以直接添加到操作声明本身。
版本中包含迁移脚本，可帮助迁移现有代码并利用新的语言功能（请参阅[迁移脚本](#MigrationScript)中的部分）。

对用户定义类型的处理方式的主要变化在于0.3 更新。 尽管以前的版本将用户定义的类型作为其基础类型的子类型处理，但这并不是继续进行的情况（另请参阅[有关重大更改的部分](#BreakingChanges)）。  
作为此更改的一部分，我们引入了可应用于特定表达式的表达式修饰符。 可以应用修饰符的 "原子" 表达式为标识符、数组项表达式和 arity-1 元组。
修饰符的绑定比任何其他表达式连结符，特别是比调用表达式连结符 `(` `)`更严格。 
`Adjoint`、`Controlled`和一个新的 "解包" 后缀运算符 `!` 被视为表达式修饰符。 将 `Adjoint` 和 `Controlled` 视为表达式修饰符消除了很多情况下需要括号。 例如，下面的表达式对于 `Op`、单一操作、`opArr` 单一操作的数组以及 `arg` 合适的参数都是有效的： 
```qsharp
    Adjoint Op (arg);
    Controlled opArr[i] (arg);
```
迁移脚本将删除大多数不必要的括号，并充分利用新功能。 但请注意，脚本不会解释代码，在极少数情况下不会考虑 `Controlled` 函子的不同解释（仅与部分应用程序结合相关）。

New 修饰符 `!` 将用户定义类型转换为其基础类型。 此强制转换已被视为以前版本中的转换，并且已自动执行。 对于用户定义类型的新解释，这不再是这样的，需要显式转换。    
下面的示例演示如何使用 new 修饰符： 
```qsharp
    newtype Unitary = (Qubit => Unit: Adjoint, Controlled);

    operation Foo (unitaries : Unitary[], q : Qubit) : Unit {

        for (unitary in unitaries[1 .. Length(unitaries)-1]) {
            // Each element of unitaries is an instance of the user-defined
            // type Unitary, so unitary! unwraps each element to an operation
            // type that we can call.
            unitary! (q);
            // The unwrap operator can also be used as a part of functor
            // expressions and when indexing into arrays.
            Adjoint unitary! (q);
            Adjoint unitaries[0]! (q);
        }
    }
```
如示例中所示，`!` 比前缀修饰符更严格，如 `Controlled` 和 `Adjoint`。

## <a name="BreakingChanges"></a>重大更改 

0\.3 更新附带了一个新编译器，其中包含少量的重大更改。
为了便于更新现有代码，编译器还提供了一个格式设置选项，该选项编译有效或无效的代码，并基于生成的编译发出格式的 Q # 代码。
所提供的工具将自动处理所有语法更改。 但是，可能需要手动对有效代码的解释方式进行更改（语义更改）。 

除了下面列出的更改之外，模式 `__*__` 其中 * 是任何非空白字符序列都是为供内部使用而保留的，不能用作符号名称。  

## <a name="syntax-changes"></a>语法更改 

- 从版本0.3 开始，数组项不再用分号分隔，而是由逗号分隔。
- 在实现特殊化声明的自动生成指令后，需要使用分号。
- If、elif-和 until 子句中的条件需要封装在括号中。 

对于所有其他语法更改，编译器将只在使用旧语法时生成警告。     
此类更改的一个示例是用户定义的专用化中的符号元组。 在以前的版本中，在以前的版本中，受控制或受控的 adjoint 专用化声明指定了单个符号参数，从0.3 开始，建议为所有特殊化提供此类符号元组，`...` 指示编译器如果需要，应根据需要迁移可调用声明中的符号。 

## <a name="semantic-changes"></a>语义更改 

0\.3 版本的最大有影响力是将用户定义类型集成到类型系统中的方式。 在以前的版本中，用户定义类型被认为是其基础类型的子类型。 在此版本中，将不再出现这种情况。 用户定义的类型现在被视为自己的不同类型，并且不存在用户定义类型与其基础类型之间的自动强制转换。 所有强制转换都需要通过 "解包" 运算符来进行显式转换 `!`，并需要强制转换才能访问用户定义类型的对象的内容。  

对类型系统的修改还包括数组的方差行为和类型参数化对象的处理。 从0.3 开始，可变数组和不可变数组都是固定的。 另外，传递到可调用的参数不能是参数化类型。 在这些情况下，必须随标识符一起传递类型参数。

以前版本的 Q # 编译器允许在应有操作值的情况下提供函数值，前提是函数值具有正确的输入和输出类型。 这是不是在 Q # 语言规范中指定的意外行为。
在0.3 编译器中，我们删除了此行为，以便不再将函数值视为操作值。
为了最大程度地减少对依赖于此 bug 的现有代码的中断，我们添加了 Canon 命名空间中的 ToOperation 函数，该函数会将函数显式转换为具有相同输入和输出类型的操作。

下面的示例演示如何使用 `ToOperation` 函数将函数 `Square` 更改为操作 `op`： 
```qsharp
namespace Microsoft.Quantum.Tests {
    open Microsoft.Quantum.Primitive;
    open Microsoft.Quantum.Canon;

    function Square(x : Int) : Int {
        return x * x;
    }

    operation ApplyOp<'T, 'U>(op : ('T => 'U), input : 'T) : 'U {
        return op(input);
    }

    operation ToOperationTest() : Unit {
        let op = ToOperation(Square);
        AssertIntEqual(ApplyOp(op, 3), 9, "ToOperation failed with Square.");
    }
}
```

## <a name="requirements"></a>要求 

Windows 10 的 Visual Studio 2017 版本15.8 或更高版本以及 Windows 10、macOS 和 Linux Visual Studio Code 版本1.27.2 或更高版本支持此版本。

量程开发工具包使用 .NET Core SDK （2.0 或更高版本）。

## <a name="installation"></a>安装  

请按照[此处](../install-guide/index.md)的安装说明进行操作。

如果当前版本的 .NET Core SDK 不是最新的，则你可能会看到警告（"可能无法解析的不同版本的不同版本之间存在冲突。"）。  但是，如果使用 .NET Core SDK （2.0 或更高版本），则可能会忽略这些警告。


- 该版本随附有多个不同的示例，演示了如何使用量程开发工具包的两个现有功能以及此版本中提供的新功能。 可在 GitHub 上的[Microsoft/量子](https://github.com/Microsoft/Quantum)存储库中找到这些示例。


## <a name="Migration"></a>将现有项目迁移到 Q # 0。3 

如果你有来自量程开发工具包版本0.2 的 Q # 项目，请遵循以下步骤将这些项目迁移到最新版本。 我们还提供了一个[迁移脚本](#MigrationScript)来帮助你进行此过程。

> [!NOTE]
> 项目需要按顺序升级。 如果有包含多个项目的解决方案，则按其引用顺序更新每个项目。


1. 在命令行中，运行 `dotnet clean`，删除所有现有的二进制文件和中间文件。
2. 在文本编辑器中，编辑 .csproj 文件，以将 `PackageReference` 的所有 "0.3.1811.2802" 版本更改为版本-preview，例如：
```xml
    <PackageReference Include="Microsoft.Quantum.Canon" Version="0.3.1811.2802" />
    <PackageReference Include="Microsoft.Quantum.Development.Kit" Version="0.3.1811.2802" />
```
4. 在命令行中，使用集成到命令行编译器中的格式设置工具通过运行以下命令来解决所有语法更改： `dotnet msbuild /t:qsharpformat`  
    - 文件将就地迁移。 所有原始文件的备份将复制到 `obj\qsharp\.backup`
    - 格式设置工具将编译项目，忽略所有编译错误，并基于生成编译生成格式化的 Q # 代码。 
       任何无法识别的符号（例如未定义的变量名）将替换为需要在设置格式后手动替换的占位符文本。 在这种情况下，会在为受影响的文件生成警告时成功进行格式设置。     
    - 在发出的代码中，将更改文件中的格式设置和特定的任何空白。 将保留注释。   
5. 运行此示例后，在代码的语义解释发生更改的情况下，你可能仍需要手动解决语义更改。 Visual Studio 中的 IntelliSense 或 Visual Studio Code 会报告所有这些错误。
    - 在 Visual Studio 2017 或 Visual Studio Code 中，打开项目或包含解决方案的根文件夹。
    - 在编辑器中打开 .qs 文件后，输出窗口应显示 Q# 语言扩展的输出。
    - 成功加载项目后（输出窗口中会出现相应指示），打开每个文件并手动解决所有剩余问题。


> [!NOTE]
> * 对于0.3 版，量子开发工具包附带的语言服务器不支持多个工作区。
> * 若要在 Visual Studio Code 中处理项目，请打开包含项目本身和所有引用项目的根文件夹。   
> * 若要在 Visual Studio 中处理解决方案，解决方案中包含的所有项目都需要位于解决方案所在的同一文件夹中，或位于其中一个子文件夹中。  
> * **不**支持迁移到0.3 和更高版本的项目之间的引用以及使用较旧包版本的项目。




## <a name="MigrationScript"></a>迁移脚本 

为了便于项目迁移，提供了可在[此处](https://raw.githubusercontent.com/Microsoft/Quantum/release/v0.3.1810/utilities/qdk-migrate.ps1)下载的 PowerShell 脚本。
此脚本可帮助将项目从量程开发工具包版本0.2 迁移到使用版本0.3。

> [!NOTE]
> 迁移脚本需要运行 Windows PowerShell 或 PowerShell Core。
> Windows PowerShell 随 Windows 10 一起预装。
> https://github.com/PowerShell/PowerShell 下载适用于 Windows、macOS 或 Linux 的 PowerShell Core。

此脚本执行以下四个步骤：

- 该项目是利用以前版本的量程开发工具包生成的，以确保迁移可能会成功。 可以使用脚本的 `-Force` 参数跳过此步骤。
- 已安装新项目模板。
- 项目将更新为使用最新版本的量程开发工具包。
- 应用了随版本0.3 的量程开发工具包一起提供的格式设置工具，以自动解决上面所述的大部分重大更改。

完成这四个步骤后，可能会有一些必须手动处理的剩余迁移问题。
使用最新版本的适用于 Visual Studio 2017 和 Visual Studio Code 的量程开发工具包扩展可以轻松地找到这些问题。

可以通过在脚本所在的文件夹中运行以下命令之一来获取脚本的文档：

```powershell
Get-Help ./qdk-migrate.ps1
Get-Help -Online ./qdk-migrate.ps1
```

> [!NOTE]
> 默认情况下，Windows 会阻止执行任何脚本作为安全措施。
> 若要允许脚本（如 `qdk-migrate.ps1`）在 Windows 上运行，你可能需要更改执行策略。
> 为此，请运行 `Set-ExecutionPolicy` 命令：
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope Process
> ```
> 当你退出 PowerShell 时，执行策略将被还原。
> 如果要保存执行策略，请使用不同的 `-Scope`值：
> ```powershell
> Set-ExecutionPolicy RemoteSigned -Scope CurrentUser
> ```

