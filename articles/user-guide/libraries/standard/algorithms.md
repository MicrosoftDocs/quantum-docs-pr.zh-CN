---
title: '中的量程算法 Q#'
description: 了解基本的量程计算算法，包括波幅放大、傅立叶转换、Draper 和 Beauregard 添加器以及相位估算。
author: QuantumWriter
ms.author: martinro
ms.date: 12/11/2017
ms.topic: article
uid: microsoft.quantum.libraries.standard.algorithms
no-loc:
- 'Q#'
- '$$v'
ms.openlocfilehash: 982103876b00718aa3b42c6bc3a07d242cde7594
ms.sourcegitcommit: 29e0d88a30e4166fa580132124b0eb57e1f0e986
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/27/2020
ms.locfileid: "92692223"
---
# <a name="quantum-algorithms"></a><span data-ttu-id="cf356-103">量程算法</span><span class="sxs-lookup"><span data-stu-id="cf356-103">Quantum Algorithms</span></span> #

## <a name="amplitude-amplification"></a><span data-ttu-id="cf356-104">振幅放大</span><span class="sxs-lookup"><span data-stu-id="cf356-104">Amplitude Amplification</span></span> ##

<span data-ttu-id="cf356-105">*振幅放大* 是量程计算的一项基本工具。</span><span class="sxs-lookup"><span data-stu-id="cf356-105">*Amplitude Amplification* is one of the fundamental tools of Quantum Computing.</span></span> <span data-ttu-id="cf356-106">这是一种基本的概念，即 Grover 的搜索、幅度估算和许多量程机器学习算法。</span><span class="sxs-lookup"><span data-stu-id="cf356-106">It is the fundamental idea that underlies Grover's search, amplitude estimation and many quantum machine learning algorithms.</span></span>  <span data-ttu-id="cf356-107">存在许多变体，并且在中， Q# 我们提供了一个基于在意波幅放大的通用版本，其中包含部分反射，以允许最大的应用程序区域。</span><span class="sxs-lookup"><span data-stu-id="cf356-107">There are many variants, and in Q# we provide a general version based on Oblivious Amplitude Amplification with Partial Reflections to allow for the widest area of application.</span></span>

<span data-ttu-id="cf356-108">振幅放大的中心思想是通过执行一系列反射来放大所需结果的概率。</span><span class="sxs-lookup"><span data-stu-id="cf356-108">The central idea behind amplitude amplification is to amplify the probability of a desired outcome occurring by performing a sequence of reflections.</span></span>  <span data-ttu-id="cf356-109">这些反射会使初始状态更接近所需的目标状态，通常称为标记的状态。</span><span class="sxs-lookup"><span data-stu-id="cf356-109">These reflections rotate the initial state closer towards a desired target state, often called a marked state.</span></span>  <span data-ttu-id="cf356-110">具体来说，如果将初始状态测量为标记状态的概率是 $ \sin ^ 2 ( \theta) $，然后在应用振幅放大后 $m $ 次，则成功的概率变为 $ \sin ^ 2 ( # B3 2m + 1) \theta) $。</span><span class="sxs-lookup"><span data-stu-id="cf356-110">Specifically, if the probability of measuring the initial state to be in a marked state is $\sin^2(\theta)$ then after applying amplitude amplification $m$ times the probability of success becomes $\sin^2((2m+1)\theta)$.</span></span>  <span data-ttu-id="cf356-111">这意味着，如果 $ \theta = \ pi/[2 (2n + 1) ] $ 用于 $n $ 的某些值，则振幅放大功能可以 \\ 在 $n $ 迭代幅度放大后提高成功到 $100% $ 的概率。</span><span class="sxs-lookup"><span data-stu-id="cf356-111">This means that if $\theta = \pi/[2(2n+1)]$ for some value of $n$ then amplitude amplification is capable of boosting the probability of success to $100\\%$ after $n$ iterations of amplitude amplification.</span></span>  <span data-ttu-id="cf356-112">由于 $ \theta = \sin ^ {-1} ( \sqrt{\pr (success) } ) $ 这意味着获取成功所需的迭代次数将几率低于预期使用随机抽样来确定标记状态时所需的次数。</span><span class="sxs-lookup"><span data-stu-id="cf356-112">Since $\theta = \sin^{-1}(\sqrt{\Pr(success)})$ this means that the number of iterations needed to obtain a success deterministically is quadratically lower than the expected number needed to find a marked state non-deterministically using random sampling.</span></span>

<span data-ttu-id="cf356-113">振幅放大的每个迭代都需要指定两个反射运算符。</span><span class="sxs-lookup"><span data-stu-id="cf356-113">Each iteration of Amplitude amplification requires that two reflection operators be specified.</span></span> <span data-ttu-id="cf356-114">具体而言，如果 $Q $ 是振幅放大循环访问，$P _0 $ 是在初始子空间上的一个投影仪运算符，并且 $P _1 $ 是标记子空间，然后 $Q =- ( \boldone-2P_0) 2P_1 $。</span><span class="sxs-lookup"><span data-stu-id="cf356-114">Specifically, if $Q$ is the amplitude amplification iterate and $P_0$ is a projector operator onto the initial subspace and $P_1$ is the projector onto the marked subspace then $Q=-(\boldone-2P_0)(\boldone -2P_1)$.</span></span>  <span data-ttu-id="cf356-115">回忆一下，投影仪是 Hermitian 运算符，其中包含本征值 $ + $1 和 $0 $，因此 $ ( \boldone-2P_0) $ 是单一的，因为在此情况下，$ \pm $1) 中，它具有作为 (unity 根的本征值。</span><span class="sxs-lookup"><span data-stu-id="cf356-115">Recall that a projector is a Hermitian operator that has eigenvalues $+1$ and $0$ and as a result $(\boldone -2P_0)$ is unitary because it has eigenvalues that are roots of unity (in this case $\pm 1$).</span></span> <span data-ttu-id="cf356-116">作为示例，请考虑使用初始状态 $H ^ {\otimes n} \ket {0} $ and 标记状态 $ \ket{m} $、$P _0 = H ^ {\otimes n} \ket \Bra {0} {0} h ^ {\otimes n} $ 和 $P _1 = \ket{m}\bra{m} $ 的情况下使用 Grover 搜索的情况。</span><span class="sxs-lookup"><span data-stu-id="cf356-116">As an example, consider the case of Grover's search with initial state $H^{\otimes n} \ket{0}$ and marked state $\ket{m}$, $P_0 = H^{\otimes n}\ket{0}\bra{0}H^{\otimes n}$ and $P_1= \ket{m}\bra{m}$.</span></span>  <span data-ttu-id="cf356-117">在幅度放大的大多数应用程序中 $P _0 $ 将成为初始状态的投影仪，这意味着 $P _0 = \boldone-2 \ 票证 {\ psi} \ 寄存器 {\ psi} $ for a vector $ \ket{\psi} $;但是，对于在意波幅 amplication $P _0 $ 通常投影到多种量程状态 ($1 例如，$P _0 $ 的重数大于 $1 $) 。</span><span class="sxs-lookup"><span data-stu-id="cf356-117">In most applications of amplitude amplification $P_0$ will be a projector onto an initial state meaning that $P_0 = \boldone -2\ket{\psi}\bra{\psi}$ for some vector $\ket{\psi}$; however, for oblivious amplitude amplication $P_0$ will typically project onto many quantum states (i.e. the multiplicity of the $+1$ eigenvalue of $P_0$ is greater than $1$).</span></span>

<span data-ttu-id="cf356-118">振幅放大后的逻辑直接在 $Q $ 的本征分解之后。</span><span class="sxs-lookup"><span data-stu-id="cf356-118">The logic behind amplitude amplification follows directly from the eigen-decomposition of $Q$.</span></span>  <span data-ttu-id="cf356-119">具体而言，$Q $ 的的本征向量 $ 表明初始状态具有非零支持可以显示为 $P _0 $ 和 $P _1 $ 的 $ + $1 本征向量的线性组合。</span><span class="sxs-lookup"><span data-stu-id="cf356-119">Specifically, the eigenvectors of $Q$ that the initial state has non-zero support over can be shown to be linear combinations of the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="cf356-120">具体而言，对于幅度放大 (的初始状态，假定它是 $P _0 $) 的 $ + $1 eigenvector，则可将其写入到 $ $ \ket{\psi} = \frac{-i}{\sqrt {2} } \left (e ^ {i\theta} \ 票证 {\ psi_ +} + e ^ {-i\theta} \ 票证 {\ psi_-} \right) ，$ $ （其中 $ \ket{\ psi_ \pm} $）本征向量 $Q $ with 本征值 $e ^ {\pm 2i \ theta} $，并且仅支持 $P 本征向量 $ 和 $P _1 $ 的 $ + $1 _0。</span><span class="sxs-lookup"><span data-stu-id="cf356-120">Specifically, the initial state for amplitude amplification (assuming it is a $+1$ eigenvector of $P_0$) can be written as $$ \ket{\psi}=\frac{-i}{\sqrt{2}}\left(e^{i\theta}\ket{\psi_+} + e^{-i\theta}\ket{\psi_-}\right), $$ where $\ket{\psi_\pm}$ are eigenvectors of $Q$ with eigenvalues $e^{\pm  2i\theta}$ and only have support on the $+1$ eigenvectors of $P_0$ and $P_1$.</span></span>  <span data-ttu-id="cf356-121">本征值 $e 是 ^ {\pm i \theta} $ 这一事实意味着运算符 $Q $ 在两个投影仪指定的二维子空间中执行旋转，而初始状态则为 ""。</span><span class="sxs-lookup"><span data-stu-id="cf356-121">The fact that the eigenvalues are $e^{\pm i \theta}$ implies that the operator $Q$ performs a rotation in a two-dimensional subspace specified by the two projectors and the initial state where the rotation angle is $2\theta$.</span></span>  <span data-ttu-id="cf356-122">这就是 $m $ $Q $ 迭代后的原因是 $ \sin ^ 2 ( [2m + 1] \theta) $。</span><span class="sxs-lookup"><span data-stu-id="cf356-122">This is why after $m$ iterations of $Q$ the success probability is $\sin^2([2m+1]\theta)$.</span></span>

<span data-ttu-id="cf356-123">这一问题的另一个有用的属性是，eigenvalue $ \theta $ 直接与 $P _0 $ 是投影仪仅限初始状态) 的情况下将标记为 (。</span><span class="sxs-lookup"><span data-stu-id="cf356-123">Another useful property that comes out of this is that the eigenvalue $\theta$ is directly related to probability that the initial state would be marked (in the case where $P_0$ is a projector onto only the initial state).</span></span>  <span data-ttu-id="cf356-124">由于 $Q $ 的 eigenphases 是 $ 2 \ theta = 2 \ sin ^ {-1} ( \sqrt{\pr (success) } ) $，因此，如果我们将阶段估算应用于 $Q $，则可以了解单一量程过程成功的概率。</span><span class="sxs-lookup"><span data-stu-id="cf356-124">Since the eigenphases of $Q$ are $2\theta = 2\sin^{-1}(\sqrt{\Pr(success)})$ it then follows that if we apply phase estimation to $Q$ then we can learn the probability of success for a unitary quantum procedure.</span></span>  <span data-ttu-id="cf356-125">这很有用，因为它需要几率更少的量程过程应用程序，以了解与其他情况下的成功概率。</span><span class="sxs-lookup"><span data-stu-id="cf356-125">This is useful because it requires quadratically fewer applications of the quantum procedure to learn the success probability than would otherwise be needed.</span></span>

<span data-ttu-id="cf356-126">Q# 将振幅放大引入为在意波幅放大的专用化。</span><span class="sxs-lookup"><span data-stu-id="cf356-126">Q# introduces amplitude amplification as a specialization of oblivious amplitude amplification.</span></span>  <span data-ttu-id="cf356-127">在意波幅放大盈利此名字对象，因为投影仪到初始 eigenspace 无需投影仪到初始状态。</span><span class="sxs-lookup"><span data-stu-id="cf356-127">Oblivious amplitude amplification earns this moniker because the projector onto the initial eigenspace need not be a projector onto the initial state.</span></span>  <span data-ttu-id="cf356-128">从这种意义上讲，该协议在意初始状态。</span><span class="sxs-lookup"><span data-stu-id="cf356-128">In this sense, the protocol is oblivious to the initial state.</span></span>  <span data-ttu-id="cf356-129">在意波幅放大的关键应用是单一 Hamiltonian 模拟方法的一些 *线性组合，其中* 初始状态是未知的，但会在模拟协议中与 ancilla 注册放大。</span><span class="sxs-lookup"><span data-stu-id="cf356-129">The key application of oblivious amplitude amplification is in certain *linear combinations of unitary* Hamiltonian simulation methods, wherein the initial state is unknown but becomes entangled with an ancilla register in the simulation protocol.</span></span>  <span data-ttu-id="cf356-130">如果将此 ancilla 寄存器测量为固定值（如 $0 $），则此类模拟方法会将所需的单一转换应用到) 系统注册的剩余 qubits (。</span><span class="sxs-lookup"><span data-stu-id="cf356-130">If this ancilla register were to be measured to be a fixed value, say $0$, then such simulation methods apply the desired unitary transformation to the remaining qubits (called the system register).</span></span>  <span data-ttu-id="cf356-131">但是，所有其他测量结果都会导致故障。</span><span class="sxs-lookup"><span data-stu-id="cf356-131">All other measurement outcomes lead to failure however.</span></span>  <span data-ttu-id="cf356-132">在意波幅放大允许使用以上推理将此度量值的成功提升为 $100 \\ % $。</span><span class="sxs-lookup"><span data-stu-id="cf356-132">Oblivious amplitude amplification allows the probability of success of this measurement to be boosted to $100\\%$ using the above reasoning.</span></span>  <span data-ttu-id="cf356-133">而且，普通幅度放大对应于系统注册为空的情况。</span><span class="sxs-lookup"><span data-stu-id="cf356-133">Further, ordinary amplitude amplification corresponds to the case where the system register is empty.</span></span>  <span data-ttu-id="cf356-134">这就是 Q# 使用在意波幅放大子例程的原因。</span><span class="sxs-lookup"><span data-stu-id="cf356-134">This is why Q# uses oblivious amplitude amplification as its fundamental amplitude amplification subroutine.</span></span>

<span data-ttu-id="cf356-135">常规例程 (`AmpAmpObliviousByReflectionPhases`) 有两个注册 `ancillaRegister` 和 `systemRegister` 。</span><span class="sxs-lookup"><span data-stu-id="cf356-135">The general routine (`AmpAmpObliviousByReflectionPhases`) has two registers that we call `ancillaRegister` and `systemRegister`.</span></span> <span data-ttu-id="cf356-136">它还接受两个 oracles 来实现必要的反射。</span><span class="sxs-lookup"><span data-stu-id="cf356-136">It also accepts two oracles for the necessary reflections.</span></span> <span data-ttu-id="cf356-137">`ReflectionOracle`仅在上起作用， `ancillaRegister` 而在 `ObliviousOracle` 两个寄存器上共同操作。</span><span class="sxs-lookup"><span data-stu-id="cf356-137">The `ReflectionOracle` acts only on the `ancillaRegister` while the `ObliviousOracle` acts jointly on both registers.</span></span> <span data-ttu-id="cf356-138">`ancillaRegister`必须将的输入初始化为第1个反射运算符 $ \boldone-2P_1 $ 的第1个 eigenstate。</span><span class="sxs-lookup"><span data-stu-id="cf356-138">The input to `ancillaRegister` must be initialized to a -1 eigenstate of the first reflection operator $\boldone -2P_1$.</span></span>

<span data-ttu-id="cf356-139">通常，oracle 在计算基础 $ \ket{0...0} $ 中准备状态。</span><span class="sxs-lookup"><span data-stu-id="cf356-139">Typically, the oracle prepares the state in the computational basis $\ket{0...0}$.</span></span> <span data-ttu-id="cf356-140">在我们的实现中， `ancillaRegister` consistes 了一个)  (qubit 的， `flagQubit` 它控制 `stateOracle` 和所需的 ancillas 的其余部分。</span><span class="sxs-lookup"><span data-stu-id="cf356-140">In our implementation, the `ancillaRegister` consistes of one qubit (`flagQubit`) that controls the `stateOracle` and the rest of the desired ancillas.</span></span> <span data-ttu-id="cf356-141">在 `stateOracle` `flagQubit` 为 $ \ket $ 时应用 {1} 。</span><span class="sxs-lookup"><span data-stu-id="cf356-141">The `stateOracle` is applied when the `flagQubit` is $\ket{1}$.</span></span>

<span data-ttu-id="cf356-142">还可以 `StateOracle` `ObliviousOracle` 通过调用来提供 oracles，而不是反射 `AmpAmpObliviousByOraclePhases` 。</span><span class="sxs-lookup"><span data-stu-id="cf356-142">One may also provide oracles `StateOracle` and `ObliviousOracle` instead of reflections via a call to `AmpAmpObliviousByOraclePhases`.</span></span>

<span data-ttu-id="cf356-143">如前所述，传统的振幅放大只是这些例程的一种特殊情况，其中， `ObliviousOracle` 为 identity 运算符，并且没有系统 qubits (（即） `systemRegister` 为空) 。</span><span class="sxs-lookup"><span data-stu-id="cf356-143">As mentioned, traditional Amplitude Amplification is just a special case of these routines where `ObliviousOracle` is the identity operator and there are no system qubits (i.e., `systemRegister` is empty).</span></span> <span data-ttu-id="cf356-144">如果要获取部分反射的阶段 (例如，对于 Grover search) ，该函数 `AmpAmpPhasesStandard` 可用。</span><span class="sxs-lookup"><span data-stu-id="cf356-144">If you wish to obtain phases for partial reflections (e.g., for Grover search), the function `AmpAmpPhasesStandard` is available.</span></span> <span data-ttu-id="cf356-145">`DatabaseSearch.qs`有关 Grover 算法的实现示例，请参阅。</span><span class="sxs-lookup"><span data-stu-id="cf356-145">Please refer to `DatabaseSearch.qs` for a sample implementation of Grover's algorithm.</span></span>

<span data-ttu-id="cf356-146">我们将 qubit 轮换阶段与反射运算符阶段相关联 [，如 G.H. Low，语](https://arxiv.org/abs/1707.05391)中所述。</span><span class="sxs-lookup"><span data-stu-id="cf356-146">We relate the single-qubit rotation phases to the reflection operator phases as described in the paper by [G.H. Low, I. L. Chuang](https://arxiv.org/abs/1707.05391).</span></span> <span data-ttu-id="cf356-147">使用的固定点阶段在 [Yoder、low 和语](https://arxiv.org/abs/1409.3305) 以及 [low、Yoder 和语](https://arxiv.org/abs/1603.03996)的阶段中进行了详细说明。</span><span class="sxs-lookup"><span data-stu-id="cf356-147">The fixed point phases that are used are detailed in [Yoder, Low and Chuang](https://arxiv.org/abs/1409.3305) along with the phases in [Low, Yoder and Chuang](https://arxiv.org/abs/1603.03996).</span></span>

<span data-ttu-id="cf356-148">对于背景，你可以从 [标准幅度放大](https://arxiv.org/abs/quant-ph/0005055) 开始，转到 [在意波幅放大](https://arxiv.org/abs/1312.1414) 简介，最后展示为 [Low 和语](https://arxiv.org/abs/1610.06546)。</span><span class="sxs-lookup"><span data-stu-id="cf356-148">For background, you could start from [Standard Amplitude Amplification](https://arxiv.org/abs/quant-ph/0005055) then move to an introduction to [Oblivious Amplitude Amplification](https://arxiv.org/abs/1312.1414) and finally generalizations presented in [Low and Chuang](https://arxiv.org/abs/1610.06546).</span></span> <span data-ttu-id="cf356-149">此整个领域的一个不错的概述演示 (与 Hamiltonian 模拟) 相关，因为它是由 [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf)提供的。</span><span class="sxs-lookup"><span data-stu-id="cf356-149">A nice overview presentation of this entire area (as it relates to Hamiltonian Simulation) was given by [Dominic Berry](http://www.dominicberry.org/presentations/Durban.pdf).</span></span>

## <a name="quantum-fourier-transform"></a><span data-ttu-id="cf356-150">量程傅立叶转换</span><span class="sxs-lookup"><span data-stu-id="cf356-150">Quantum Fourier Transform</span></span> ##

<span data-ttu-id="cf356-151">傅立叶转换是一种古典型分析工具，与量程计算一样重要。</span><span class="sxs-lookup"><span data-stu-id="cf356-151">The Fourier transform is a fundamental tool of classical analysis and is just as important for quantum computations.</span></span>
<span data-ttu-id="cf356-152">此外，在设计量程算法时， *量程傅立叶转换* (QFT) 远远超过了在传统计算机上可能会出现的情况。</span><span class="sxs-lookup"><span data-stu-id="cf356-152">In addition, the efficiency of the *quantum Fourier transform* (QFT) far surpasses what is possible on a classical machine making it one of the first tools of choice when designing a quantum algorithm.</span></span>

<span data-ttu-id="cf356-153">作为 QFT 的大致通用化，我们提供了这样的 <xref:Microsoft.Quantum.Canon.ApproximateQft> 操作：通过修剪旋转（对所需的算法准确性并不是绝对必需的）来实现进一步的优化。</span><span class="sxs-lookup"><span data-stu-id="cf356-153">As an approximate generalization of the QFT, we provide the <xref:Microsoft.Quantum.Canon.ApproximateQft> operation that allows for further optimizations by pruning rotations that aren't strictly necessary for the desired algorithmic accuracy.</span></span>
<span data-ttu-id="cf356-154">大致的 QFT 要求 dyadic $Z $ 旋转操作以及 <xref:Microsoft.Quantum.Intrinsic.RFrac> <xref:Microsoft.Quantum.Intrinsic.H> 操作。</span><span class="sxs-lookup"><span data-stu-id="cf356-154">The approximate QFT requires the dyadic $Z$-rotation operation <xref:Microsoft.Quantum.Intrinsic.RFrac> as well as the <xref:Microsoft.Quantum.Intrinsic.H> operation.</span></span>
<span data-ttu-id="cf356-155">输入和输出假设编码为大字节序编码---也就是说，带有索引的 qubit `0` 在二进制整数表示形式的最左边 (最高) 位进行编码。</span><span class="sxs-lookup"><span data-stu-id="cf356-155">The input and output are assumed to be encoded in big endian encoding---that is, the qubit with index `0` is encoded in the left-most (highest) bit of the binary integer representation.</span></span>
<span data-ttu-id="cf356-156">这与 [票证表示法](xref:microsoft.quantum.concepts.dirac)一致，因为状态 $ \ket $ 中的三个 qubits 的寄存器对应 $q 于状态 $ \ket $ 中的三个， {100} {1} 而 $q _1 $ 和 $q _2 $ 都处于状态 $ \ket {0} $ 中。</span><span class="sxs-lookup"><span data-stu-id="cf356-156">This aligns with [ket notation](xref:microsoft.quantum.concepts.dirac), as a register of three qubits in the state $\ket{100}$ corresponds to $q_0$ being in the state $\ket{1}$ while $q_1$ and $q_2$ are both in state $\ket{0}$.</span></span>
<span data-ttu-id="cf356-157">近似值参数 $a $ 确定 $Z $ 旋转的修剪级别，即 $a \in [0 ... n] $。</span><span class="sxs-lookup"><span data-stu-id="cf356-157">The approximation parameter $a$ determines the pruning level of the $Z$-rotations, i.e., $a \in [0..n]$.</span></span>
<span data-ttu-id="cf356-158">在这种情况下，所有 $Z $-循环 $ 2 \ pi/2 ^ k $，其中 $k > $ 将从 QFT 线路中删除。</span><span class="sxs-lookup"><span data-stu-id="cf356-158">In this case all $Z$-rotations $2\pi/2^k$ where $k > a$ are removed from the QFT circuit.</span></span>
<span data-ttu-id="cf356-159">已知 $k \ge \ log_2 (n) + \ log_2 (1/\epsilon) + $3。</span><span class="sxs-lookup"><span data-stu-id="cf356-159">It is known that for $k \ge \log_2(n) + \log_2(1 / \epsilon) + 3$.</span></span> <span data-ttu-id="cf356-160">一个可以绑定 $ \\ | \operatorname{QFT}-\operatorname{AQFT} \\ | < \epsilon $。</span><span class="sxs-lookup"><span data-stu-id="cf356-160">one can bound $\\| \operatorname{QFT} - \operatorname{AQFT} \\| < \epsilon$.</span></span>
<span data-ttu-id="cf356-161">此处 \\ 的 $ | \cdot \\ | $ 是运算符标准，在本例中是 $ ( \Operatorname{qft}-\operatorname{AQFT} ) # A2\OPERATORNAME {QFT}-\operatorname{AQFT} ) ^ \dagger $ 的最大 [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) 的平方根。</span><span class="sxs-lookup"><span data-stu-id="cf356-161">Here $\\|\cdot\\|$ is the operator norm which in this case is the square root of the largest [eigenvalue](xref:microsoft.quantum.concepts.matrix-advanced) of $(\operatorname{QFT} - \operatorname{AQFT})(\operatorname{QFT} - \operatorname{AQFT})^\dagger$.</span></span>

## <a name="arithmetic"></a><span data-ttu-id="cf356-162">算术</span><span class="sxs-lookup"><span data-stu-id="cf356-162">Arithmetic</span></span> ##

<span data-ttu-id="cf356-163">正如算术在传统计算中扮演中心角色一样，在量程计算中也是必不可少的。</span><span class="sxs-lookup"><span data-stu-id="cf356-163">Just as arithmetic plays a central role in classical computing, it is also indispensable in quantum computing.</span></span>  <span data-ttu-id="cf356-164">诸如选定的分解算法、量程模拟方法以及许多 oracular 算法等算法依赖于一致的算术运算。</span><span class="sxs-lookup"><span data-stu-id="cf356-164">Algorithms such as Shor's factoring algorithm, quantum simulation methods as well as many oracular algorithms rely upon coherent arithmetic operations.</span></span>  <span data-ttu-id="cf356-165">用于在量程创建线路上进行算法生成的大多数方法。</span><span class="sxs-lookup"><span data-stu-id="cf356-165">Most approaches to arithmetic build upon quantum adder circuits.</span></span>  <span data-ttu-id="cf356-166">最简单的添加程序会将传统输入 $b $，并将值添加到包含整数 $ \ket{a} $ 的量程状态。</span><span class="sxs-lookup"><span data-stu-id="cf356-166">The simplest adder takes a classical input $b$ and adds the value to a quantum state holding an integer $\ket{a}$.</span></span>  <span data-ttu-id="cf356-167">从数学上来说，\operatorname{Add} 的 "提供程序" (表示针对经典 $b 输入的 $ (b) $) 的属性</span><span class="sxs-lookup"><span data-stu-id="cf356-167">Mathematically, the adder (which we denote $\operatorname{Add}(b)$ for classical input $b$) has the property that</span></span>

<span data-ttu-id="cf356-168">$ $ \operatorname{Add} (b) \ket{a} = \ket{a + b}。</span><span class="sxs-lookup"><span data-stu-id="cf356-168">$$ \operatorname{Add}(b)\ket{a}=\ket{a + b}.</span></span>
<span data-ttu-id="cf356-169">$ $ 这一基本的增加，incrementer 比一个增加程序更多。</span><span class="sxs-lookup"><span data-stu-id="cf356-169">$$ This basic adder circuit is more of an incrementer than an adder.</span></span>
<span data-ttu-id="cf356-170">它可以通过 $ $ \operatorname{Add}\ket{a}\ket{b} = \ket{a}\ket{a + b}、$ $n $ ( 窗体的添加器的 $ 受控应用程序转换为具有两个量程输入的转换程序 \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda \_ {a \_ 0} \Left \operatorname{Add} (1) \Right) \Lambda \_ {a \_ 1} \left ( \operatorname{Add} (2) \right) \Lambda \_ {a \_ 2} \left ( \operatorname{Add} (4) \right) \cdots \Lambda \_ {a {} \_ } \left ( \operatorname{Add} ( {) n-1}}) \right & \ket{a}\ket{b} \\ \\ = \ket{a} \ket{b + a}，\end{align} 用于 $n $ 位整数 $a $ 和 $b $，加法取模 $ 2 ^ n $。</span><span class="sxs-lookup"><span data-stu-id="cf356-170">It can be converted into an adder that has two quantum inputs via $$ \operatorname{Add}\ket{a}\ket{b}=\ket{a}\ket{a+b}, $$ using $n$ controlled applications of adders of the form \begin{align} \operatorname{Add} \ket{a} \ket{b} & = \Lambda\_{a\_0} \left(\operatorname{Add}(1) \right) \Lambda\_{a\_1} \left(\operatorname{Add}(2) \right) \Lambda\_{a\_2} \left(\operatorname{Add}(4) \right) \cdots \Lambda\_{a\_{n-1}} \left(\operatorname{Add}({{n-1}}) \right) \ket{a}\ket{b} \\\\ & = \ket{a} \ket{b + a}, \end{align} for $n$-bit integers $a$ and $b$ and addition modulo $2^n$.</span></span>  <span data-ttu-id="cf356-171">请注意，表示法 $ \Lambda \_ x () $ 是指将任何操作 $A $ 引用到该操作的受控版本，并使用 qubit $x $ 作为控件。</span><span class="sxs-lookup"><span data-stu-id="cf356-171">Recall that the notation $\Lambda\_x(A)$ refers, for any operation $A$, to the controlled version of that operation with the qubit $x$ as control.</span></span>

<span data-ttu-id="cf356-172">同样，经典控制乘法 (的模块化形式对于选定的分解算法至关重要，) 可以通过使用一系列类似的受控添加来执行： \begin{align} \operatorname{Mult} (一个) \ket{x}\ket{b} & = \Lambda \_ {x \_ 0} \Left ( \operatorname{add} (2 ^ 0 a) \Right) \Lambda \_ { \_ 1} \left ( \operatorname{add} (2 ^ 1a) \right) \Lambda \_ {a \_ 2} \left ( \operatorname{add} (2 ^ 2 a) \right) \cdots \Lambda \_ {x \_ {n-1}} \left ( \operatorname{add} ( {2 ^ {n-1}}) \right) \ket{x}\ket{b} \\ \\ & = \ket{x}\ket{b + ax}。</span><span class="sxs-lookup"><span data-stu-id="cf356-172">Similarly, classically controlled multiplication (a modular form of which is essential for Shor's factoring algorithm) can be performed by using a similar series of controlled  additions: \begin{align} \operatorname{Mult}(a)\ket{x}\ket{b} & = \Lambda\_{x\_0}\left(\operatorname{Add}(2^0 a)\right) \Lambda\_{a\_1}\left(\operatorname{Add}(2^1a)\right) \Lambda\_{a\_2}\left(\operatorname{Add}(2^2 a)\right) \cdots \Lambda\_{x\_{n-1}} \left(\operatorname{Add}({2^{n-1}}a) \right)\ket{x}\ket{b} \\\\ & = \ket{x}\ket{b+ax}.</span></span>
<span data-ttu-id="cf356-173">\end{align} 在量程计算机上有一个个很微妙，你可能会注意到上面 $ \operatorname{Mult} $ 的定义。</span><span class="sxs-lookup"><span data-stu-id="cf356-173">\end{align} There is a subtlety with multiplication on quantum computers that you may notice from the definition of $\operatorname{Mult}$ above.</span></span>  <span data-ttu-id="cf356-174">与此不同，此线路的量程版本将输入的产品存储在辅助寄存器中而不是输入寄存器中。</span><span class="sxs-lookup"><span data-stu-id="cf356-174">Unlike addition, the quantum version of this circuit stores the product of the inputs in an ancillary register rather than in the input register.</span></span>  <span data-ttu-id="cf356-175">在此示例中，寄存器用值 $b $ 进行初始化，但它通常会开始将值保留为零。</span><span class="sxs-lookup"><span data-stu-id="cf356-175">In this example, the register is initialized with the value $b$, but typically it will start holding the value zero.</span></span>  <span data-ttu-id="cf356-176">这在中是必需的，因为一般情况下，一般 $a $ 和 $x $ 之间没有乘法逆。</span><span class="sxs-lookup"><span data-stu-id="cf356-176">This is needed in because in general there is not a multiplicative inverse for general $a$ and $x$.</span></span>  <span data-ttu-id="cf356-177">由于所有量程操作（节省度量值）都是可逆的，因此我们需要保留足够的信息来反转乘法。</span><span class="sxs-lookup"><span data-stu-id="cf356-177">Since all quantum operations, save measurement, are reversible we need to keep enough information around to invert the multiplication.</span></span>  <span data-ttu-id="cf356-178">出于此原因，结果将存储在单独的数组中。</span><span class="sxs-lookup"><span data-stu-id="cf356-178">For this reason the result is stored in a separate array.</span></span>  <span data-ttu-id="cf356-179">在单独的寄存器中保存不可逆操作（如乘法）输出的这一技巧称为 Charlie Bennett 后的 "Bennett 技巧"，它是可逆计算和量程计算的一项基本工具。</span><span class="sxs-lookup"><span data-stu-id="cf356-179">This trick of saving the output of an irreversible operation, like multiplication, in a separate register is known as the "Bennett trick" after Charlie Bennett and is a fundamental tool in both reversible and quantum computing.</span></span>

<span data-ttu-id="cf356-180">已建议使用许多量程线路进行添加，并且每个线路都在 qubits (空间的数量) 和 (时间) 所需的操作数中探讨了不同的折衷。</span><span class="sxs-lookup"><span data-stu-id="cf356-180">Many quantum circuits have been proposed for addition and each explores a different tradeoff in terms of the number of qubits (space) and the number of gate operations (time) required.</span></span>  <span data-ttu-id="cf356-181">我们将在以下两个高空间高效的添加器（称为 Draper 的 Beauregard 和的）中查看。</span><span class="sxs-lookup"><span data-stu-id="cf356-181">We review two highly space efficient adders below known as the Draper adder and the Beauregard adder.</span></span>

### <a name="draper-adder"></a><span data-ttu-id="cf356-182">Draper</span><span class="sxs-lookup"><span data-stu-id="cf356-182">Draper Adder</span></span> ###

<span data-ttu-id="cf356-183">Draper 添加是最巧妙的量程添加器之一，因为它直接调用量程属性以执行添加。</span><span class="sxs-lookup"><span data-stu-id="cf356-183">The Draper adder is arguably one of the most elegant quantum adders, as it directly invokes quantum properties to perform addition.</span></span>  <span data-ttu-id="cf356-184">Draper 加载程序背后的见解是，可以使用傅立叶变换将相位移位转换成移位。</span><span class="sxs-lookup"><span data-stu-id="cf356-184">The insight behind the Draper adder is that the Fourier transform can be used to translate phase shifts into a bit shift.</span></span>  <span data-ttu-id="cf356-185">接下来，通过应用傅立叶变换，应用适当的阶段移位，然后撤消傅立叶转换，可以实现一个转换程序。</span><span class="sxs-lookup"><span data-stu-id="cf356-185">It then follows that by applying a Fourier transform, applying appropriate phase shifts, and then undoing the Fourier transform you can implement an adder.</span></span>  <span data-ttu-id="cf356-186">与其他许多已建议的添加器不同，Draper 的创建程序显式使用通过量程傅立叶转换引入的量程效果。</span><span class="sxs-lookup"><span data-stu-id="cf356-186">Unlike many other adders that have been proposed, the Draper adder explicitly uses quantum effects introduced through the quantum Fourier transform.</span></span>  <span data-ttu-id="cf356-187">它没有典型的传统对应项。</span><span class="sxs-lookup"><span data-stu-id="cf356-187">It does not have a natural classical counterpart.</span></span>  <span data-ttu-id="cf356-188">下面给出了 Draper 提供的特定步骤。</span><span class="sxs-lookup"><span data-stu-id="cf356-188">The specific steps of the Draper adder are given below.</span></span>

<span data-ttu-id="cf356-189">假设您有两个 $n $ bit qubit 寄存器将整数 $a $ 和 $b $，然后针对所有 $a $ $ $ \operatorname{QFT}\ket{a} = \frac {1} {\sqrt{2 ^ n}} \sum \_ {j = 0} ^ {2 ^ n-1} e ^ {i2\pi (aj) /2 ^ n} \ket{j}。</span><span class="sxs-lookup"><span data-stu-id="cf356-189">Assume that you have two $n$-bit qubit registers storing the integers $a$ and $b$ then for all $a$ $$ \operatorname{QFT}\ket{a}= \frac{1}{\sqrt{2^n}}\sum\_{j=0}^{2^n-1} e^{i2\pi(aj)/2^n} \ket{j}.</span></span>
<span data-ttu-id="cf356-190">$ $ 如果我们定义 $ $ \ket{\phi \_ k () } = \frac {1} {\sqrt {2} } \left ( \ket {0} + e ^ {i2\pi a/2 ^ k} \ket {1} \right) ，$ $ 然后在某个代数之后，可以看到 $ $ \operatorname{QFT}\ket{a} = \ket{\phi \_ 1 () } \otimes \cdots \otimes \ket{\phi \_ n () }。</span><span class="sxs-lookup"><span data-stu-id="cf356-190">$$ If we define $$ \ket{\phi\_k(a)} = \frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi a /2^k}\ket{1} \right), $$ then after some algebra you can see that $$ \operatorname{QFT}\ket{a}=\ket{\phi\_1(a)}\otimes \cdots \otimes \ket{\phi\_n(a)}.</span></span>
<span data-ttu-id="cf356-191">$ $ 要执行转换程序的路径在观察到输入的总和可以写为 $ $ \ket{a + b} = \operatorname{QFT} ^ {-1} \ket{\phi \_ 1 (a + b) } \otimes \cdots \otimes \ket{\phi \_ n (a + b) } 后，就变得清楚。</span><span class="sxs-lookup"><span data-stu-id="cf356-191">$$ The path towards performing an adder then becomes clear after observing that the sum of the inputs can be written as $$ \ket{a+b}=\operatorname{QFT}^{-1}\ket{\phi\_1(a+b)}\otimes \cdots \otimes \ket{\phi\_n(a+b)}.</span></span>
<span data-ttu-id="cf356-192">$ $ $B $ 和 $a $ 的整数，则可以通过使用 $b $ 的位作为控件，在分解中的每个 qubits 上执行受控制的阶段旋转。</span><span class="sxs-lookup"><span data-stu-id="cf356-192">$$ The integers $b$ and $a$ can then be added by performing controlled-phase rotation on each of the qubits in the decomposition using the bits of $b$ as controls.</span></span>

<span data-ttu-id="cf356-193">请注意，对于任何整数 $j $ 和实数 $x $，$e ^ {i2\pi (x + j) } = e ^ {i2\pi x} $，可以进一步简化此扩展。</span><span class="sxs-lookup"><span data-stu-id="cf356-193">This expansion can be further simplified by noting that for any integer $j$ and real number $x$, $e^{i2\pi(x+j)}=e^{i2\pi x}$.</span></span>  <span data-ttu-id="cf356-194">这是因为，如果在圆圈中旋转 $ 360 ^ {\circ} $ 度数 ($ 2 \ pi $ 弧度) ，则最终会精确到开始处。</span><span class="sxs-lookup"><span data-stu-id="cf356-194">This is because if you rotate $360^{\circ}$ degrees ($2\pi$ radians) in a circle then you end up precisely where you started.</span></span>  <span data-ttu-id="cf356-195">因此 $e ^ {i2\pi x} $ $x $ 的唯一重要部分是 $x $ 的小数部分。</span><span class="sxs-lookup"><span data-stu-id="cf356-195">The only important part of $x$ for $e^{i2\pi x}$ is therefore the fractional part of $x$.</span></span>  <span data-ttu-id="cf356-196">具体而言，如果我们的二进制扩展形式 $x = y +0。 x \_ 0x \_ 2 \ ldots x \_ n $ then $e ^ {i2\pi x} = e ^ {i2\pi (0. x \_ 0x \_ 2 \ ldots x \_ {n-1} ) } $，因此 $ $ \ket{\phi \_ k (a + b) } = \frac {1} {\sqrt {2} } \left ( \ket {0} + e ^ {i2\pi [a/2 ^ k +0。 b \_ K\ldots b \_ 1]} \ket {1} \right) 。 $ $ 这意味着，如果在 $ \ket{a} $ 的傅立叶转换的扩展中增加了每个 tensor 因素，则旋转收缩的数量将随着 $k $ 减而增加。</span><span class="sxs-lookup"><span data-stu-id="cf356-196">Specifically, if we have a binary expansion of the form $x=y+0.x\_0x\_2\ldots x\_n$ then $e^{i2\pi x}=e^{i2\pi (0.x\_0x\_2\ldots x\_{n-1})}$ and hence $$\ket{\phi\_k(a+b)}=\frac{1}{\sqrt{2}}\left(\ket{0} + e^{i2\pi [a/2^k+0.b\_k\ldots b\_1]}\ket{1} \right).$$ This means that if we perform addition by incrementing each of the tensor factors in the expansion of the Fourier transform of $\ket{a}$ then the number of rotations shrinks as $k$ decreases.</span></span>  <span data-ttu-id="cf356-197">这极大地减少了增加插件所需的量程入口数。</span><span class="sxs-lookup"><span data-stu-id="cf356-197">This substantially reduces the number of quantum gates needed in the adder.</span></span>  <span data-ttu-id="cf356-198">我们指出了傅立叶变换、相位加法和反傅立叶变换步骤，这些步骤包含 Draper 添加程序作为 $ \operatorname{QFT} ^ {-1} \left ( \Phi \\ \! \operatorname{ADD}\right) \operatorname{QFT} $。</span><span class="sxs-lookup"><span data-stu-id="cf356-198">We denote the Fourier transform, phase addition and the inverse Fourier transform steps that comprise the Draper adder as $\operatorname{QFT}^{-1} \left(\phi\\\!\operatorname{ADD}\right) \operatorname{QFT}$.</span></span> <span data-ttu-id="cf356-199">下面显示了使用这种简化实现整个过程的量程线路。</span><span class="sxs-lookup"><span data-stu-id="cf356-199">A quantum circuit that uses this simplification to implement the entire process can be seen below.</span></span>

![显示为线路关系图的 Draper](~/media/draper.svg)

<span data-ttu-id="cf356-201">线路中的每个受控 $e ^ {i2 \ pi/k} $ 入口都指受控的阶段入口。</span><span class="sxs-lookup"><span data-stu-id="cf356-201">Each controlled $e^{i2\pi/k}$ gate in the circuit refers to a controlled-phase gate.</span></span>  <span data-ttu-id="cf356-202">此类入口具有属性，该属性位于其作用的 qubits 对上，$ \ket {00} \mapsto \ket {00} $ 但 $ \ket {11} \mapsto e ^ {i2 \ pi/k} \ 票证 {11} $。</span><span class="sxs-lookup"><span data-stu-id="cf356-202">Such gates have the property that on the pair of qubits on which they act, $\ket{00}\mapsto \ket{00}$ but $\ket{11}\mapsto e^{i2\pi/k}\ket{11}$.</span></span>  <span data-ttu-id="cf356-203">利用此线路，我们可以使用除存储输入和输出所需的其他 qubits 以外的其他任何功能来执行添加。</span><span class="sxs-lookup"><span data-stu-id="cf356-203">This circuit allows us to perform addition using no additional qubits apart from those needed to store the inputs and the outputs.</span></span>

### <a name="beauregard-adder"></a><span data-ttu-id="cf356-204">Beauregard</span><span class="sxs-lookup"><span data-stu-id="cf356-204">Beauregard Adder</span></span> ###

<span data-ttu-id="cf356-205">Beauregard 添加程序是一个量程模块化添加程序，它使用 Draper 添加程序来对任意值为正整数 $N $ 执行加法取模 $N $。</span><span class="sxs-lookup"><span data-stu-id="cf356-205">The Beauregard adder is a quantum modular adder that uses the Draper adder in order to perform addition modulo $N$ for an arbitrary value positive integer $N$.</span></span>  <span data-ttu-id="cf356-206">量程模块化添加器（如 Beauregard 外接程序）的重要性，就是在选定算法中用于因式分解的模块求幂步骤中，其使用范围很大。</span><span class="sxs-lookup"><span data-stu-id="cf356-206">The significance of quantum modular adders, such as the Beauregard adder, stems to a large extent from their use in the modular exponentiation step within Shor's algorithm for factoring.</span></span>  <span data-ttu-id="cf356-207">量程模块化外接程序对量程输入 $ \ket{b} $ 和经典输入 $a $ 具有以下操作，其中 $a $ 和 $b $ 被承诺为整数 mod $N $，这意味着它们处于 [0，\ldots，N-1] $ 的间隔。</span><span class="sxs-lookup"><span data-stu-id="cf356-207">A quantum modular adder has the following action for quantum input $\ket{b}$ and classical input $a$ where $a$ and $b$ are promised to be integers mod $N$, meaning that they are in the interval $[0,\ldots, N-1]$.</span></span>

<span data-ttu-id="cf356-208">$ $ \ket{b}\rightarrow \ket{b + a \text{mod} N} = \begin{cases} \ket{b + a}，& b + a < N \\ \\ \Ket{b + n}，& (b + a) \ge N \end{cases}。</span><span class="sxs-lookup"><span data-stu-id="cf356-208">$$ \ket{b}\rightarrow \ket{b+a \text{ mod }N}=\begin{cases} \ket{b+a},& b+a < N\\\\ \ket{b+a-N},& (b+a)\ge N \end{cases}.</span></span>
$$

<span data-ttu-id="cf356-209">Beauregard 添加插件使用 Draper 添加项，或更具体的 $ \phi \\ \! \operatorname{ADD} $，以在阶段中添加 $a $ 和 $b $。</span><span class="sxs-lookup"><span data-stu-id="cf356-209">The Beauregard adder uses the Draper adder, or more specifically $\phi\\\!\operatorname{ADD}$, to add $a$ and $b$ in phase.</span></span>  <span data-ttu-id="cf356-210">然后，它将使用相同操作来确定是否 $a + b <N $，方法是在 $a + b<$0 中减去 $N $ 和测试。</span><span class="sxs-lookup"><span data-stu-id="cf356-210">It then uses the same operation to identify whether $a+b <N$ by subtracting $N$ and testing if $a+b-N<0$.</span></span>  <span data-ttu-id="cf356-211">线路将此信息存储在辅助 qubit 中，然后在 $a + b<N $ 时，将 $N $ 返回寄存器。</span><span class="sxs-lookup"><span data-stu-id="cf356-211">The circuit stores this information in an ancillary qubit and then adds $N$ back the register if $a+b<N$.</span></span>  <span data-ttu-id="cf356-212">然后，它会通过 uncomputing 此辅助 (来完成此步骤，这是为了确保 ancilla 可以在) 调用中的重新分配后被释放。</span><span class="sxs-lookup"><span data-stu-id="cf356-212">It then concludes by uncomputing this ancillary bit (this step is needed to ensure that the ancilla can be de-allocated after calling the adder).</span></span>  <span data-ttu-id="cf356-213">下面给出了 Beauregard 提供程序的线路。</span><span class="sxs-lookup"><span data-stu-id="cf356-213">The circuit for the Beauregard adder is given below.</span></span>

![显示为线路关系图的 Beauregard](~/media/beau.svg)

<span data-ttu-id="cf356-215">此处，入口 $ \Phi \\ \! \operatorname{ADD} $ 采用与 $ \Phi \operatorname{ADD} $ 相同的形式 \\ \! ，只不过在此上下文中，输入为经典而不是量程。</span><span class="sxs-lookup"><span data-stu-id="cf356-215">Here the gate $\Phi\\\!\operatorname{ADD}$ takes the same form as $\phi\\\!\operatorname{ADD}$ except that in this context the input is classical rather than quantum.</span></span>  <span data-ttu-id="cf356-216">这允许将 $ \Phi \Operatorname{ADD} $ 中的受控阶段 \\ \! 替换为阶段入口，然后可以将这些阶段编译成更少的操作，减少了执行程序所需的 qubits 和入口数。</span><span class="sxs-lookup"><span data-stu-id="cf356-216">This allows the controlled phases in $\Phi\\\!\operatorname{ADD}$ to be replaced with phase gates that can then be compiled together into fewer operations to reduce both the number of qubits and number of gates needed for the adder.</span></span>

<span data-ttu-id="cf356-217">有关更多详细信息，请参阅 [Roetteler、Beth](http://doi.org/10.1007/s00200-008-0072-2 ) 和 [Coppersmith](https://arxiv.org/abs/quant-ph/0201067)。</span><span class="sxs-lookup"><span data-stu-id="cf356-217">For more details, please refer to [M. Roetteler, Th. Beth](http://doi.org/10.1007/s00200-008-0072-2 ) and [D. Coppersmith](https://arxiv.org/abs/quant-ph/0201067).</span></span>

### <a name="quantum-phase-estimation"></a><span data-ttu-id="cf356-218">量子相位估计</span><span class="sxs-lookup"><span data-stu-id="cf356-218">Quantum Phase Estimation</span></span> ###

<span data-ttu-id="cf356-219">量程傅立叶转换的一个特别重要的应用是了解单一运算符（称为 *阶段估算* 的问题）的本征值。</span><span class="sxs-lookup"><span data-stu-id="cf356-219">One particularly important application of the quantum Fourier transform is to learn the eigenvalues of unitary operators, a problem known as *phase estimation* .</span></span>
<span data-ttu-id="cf356-220">假设单一 $U $ 和状态 $ \ket{\phi} $，$ \ket{\phi} $ 是包含未知 eigenvalue $ \phi $ 的 $U $ 的 eigenstate，\begin{equation} U\ket {\ phi} = \phi\ket{\phi}。</span><span class="sxs-lookup"><span data-stu-id="cf356-220">Consider a unitary $U$ and a state $\ket{\phi}$ such that $\ket{\phi}$ is an eigenstate of $U$ with unknown eigenvalue $\phi$, \begin{equation} U\ket{\phi} = \phi\ket{\phi}.</span></span>
<span data-ttu-id="cf356-221">\end{equation} 如果仅有权访问作为 oracle $U $，则可以通过使用应用于受控操作目标的 $Z $ 旋转传播回控件来了解阶段 $ \phi $。</span><span class="sxs-lookup"><span data-stu-id="cf356-221">\end{equation} If we only have access to $U$ as an oracle, then we can learn the phase $\phi$ by utilizing that $Z$ rotations applied to the target of a controlled operation propagate back onto the control.</span></span>

<span data-ttu-id="cf356-222">假设 $V $ 是 $U $ 的受控应用程序，因此 \begin{align} V ( \ket {0} \otimes \ket{\phi} ) & = \ket \otimes \ket{\phi} \textrm{ {0} \\ \\ and} V ( \ket \otimes {1} \ket{\phi} ) & = e ^ {i \phi} \ket {1} \otimes \ket{\phi}。</span><span class="sxs-lookup"><span data-stu-id="cf356-222">Suppose that $V$ is a controlled application of $U$, such that \begin{align} V (\ket{0} \otimes \ket{\phi}) & =            \ket{0} \otimes \ket{\phi} \\\\ \textrm{ and } V (\ket{1} \otimes \ket{\phi}) & = e^{i \phi} \ket{1} \otimes \ket{\phi}.</span></span>
<span data-ttu-id="cf356-223">然后，通过 \end{align}、\begin{align} V ( \ket{+} \otimes \ket{\phi} ) & = \frac{ ( \ket {0} \otimes \ket{\phi} ) + e ^ {i \phi} ( \ket {1} \otimes \ket{\phi} ) } {\sqrt {2} }。</span><span class="sxs-lookup"><span data-stu-id="cf356-223">\end{align} Then, by linearity, \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{ (\ket{0} \otimes \ket{\phi}) + e^{i \phi} (\ket{1} \otimes \ket{\phi}) }{\sqrt{2}}.</span></span>
<span data-ttu-id="cf356-224">\end{align} 我们可以收集术语来查找 \begin{align} V ( \ket{+} \otimes \ket{\phi} ) & = \frac{\ket {0} + e ^ {i \phi} \ket {1} } {\sqrt {2} } \otimes \ket{\phi} \\ \\ & = (R_1 ( \phi) \ket{+} ) \otimes \ket{\phi}，\end{align}，其中 $R _1 $ 是操作应用的单一 <xref:Microsoft.Quantum.Intrinsic.R1> 。</span><span class="sxs-lookup"><span data-stu-id="cf356-224">\end{align} We can collect terms to find that \begin{align} V(\ket{+} \otimes \ket{\phi}) & = \frac{\ket{0} + e^{i \phi} \ket{1}}{\sqrt{2}} \otimes \ket{\phi} \\\\ & = (R_1(\phi) \ket{+}) \otimes \ket{\phi}, \end{align} where $R_1$ is the unitary applied by the <xref:Microsoft.Quantum.Intrinsic.R1> operation.</span></span>
<span data-ttu-id="cf356-225">换句话说，应用 $V $ 的影响与将 $R _1 $ 应用于未知角度完全相同，即使我们仅有权访问作为 oracle $V $。</span><span class="sxs-lookup"><span data-stu-id="cf356-225">Put differently, the effect of applying $V$ is precisely the same as applying $R_1$ with an unknown angle, even though we only have access to $V$ as an oracle.</span></span>
<span data-ttu-id="cf356-226">因此，对于本文的其余部分，我们将根据 $R _1 ( \phi) $ （通过使用所谓的 *阶段 kickback* 来实现）讨论阶段估算。</span><span class="sxs-lookup"><span data-stu-id="cf356-226">Thus, for the rest of this discussion we will discuss phase estimation in terms of $R_1(\phi)$, which we implement by using so-called *phase kickback* .</span></span>

<span data-ttu-id="cf356-227">由于在此过程后，控件和目标注册仍处于 untangled 状态，因此，我们可以将 $ \ket{\phi} $ 作为 $U ^ $2 的受控应用程序的目标，以便在州 $R _1 (2 \phi) \ket{+} $ 中准备第二个控制 qubit。</span><span class="sxs-lookup"><span data-stu-id="cf356-227">Since the control and target register remain untangled after this process, we can reuse $\ket{\phi}$ as the target of a controlled application of $U^2$ to prepare a second control qubit in the state $R_1(2 \phi) \ket{+}$.</span></span>
<span data-ttu-id="cf356-228">继续以这种方式，我们可以获取形式为 \begin{align} \ket{\psi} & = \ sum_ {j = 0} ^ n R_1 (2 ^ j \phi) \ket{+} \\ \\ & \propto \ bigotimes_ {j = 0} ^ {n} \left ( \ket {0} + \exp (i 2 ^ {j} \phi) \ket {1} \right) \\ \\ & \propto \ sum_ {k = 0} ^ {2 ^ n-1} \exp (i \phi k) \ket{k} \end{align}，其中 $n $ 是我们需要的精度位数。而且，我们已使用 $ {} \propto {} $ 来指示我们已取消标准化系数 $1/\sqrt{2 ^ n} $。</span><span class="sxs-lookup"><span data-stu-id="cf356-228">Continuing in this way, we can obtain a register of the form \begin{align} \ket{\psi} & = \sum_{j = 0}^n R_1(2^j \phi) \ket{+} \\\\ & \propto \bigotimes_{j=0}^{n} \left(\ket{0} + \exp(i 2^{j} \phi) \ket{1}\right) \\\\ & \propto \sum_{k = 0}^{2^n - 1} \exp(i \phi k) \ket{k} \end{align} where $n$ is the number of bits of precision that we require, and where we have used ${} \propto {}$ to indicate that we have suppressed the normalization factor of $1 / \sqrt{2^n}$.</span></span>

<span data-ttu-id="cf356-229">如果我们假设 $ \phi = 2 \pi p/2 ^ k $ 用于整数 $p $，则我们会将其识别为 $ \ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots .. p_n} $，其中 $p _j $ 是 $2 \textrm{th}} \pi $ 的 $j ^ {\phi $ 位。</span><span class="sxs-lookup"><span data-stu-id="cf356-229">If we assume that $\phi = 2 \pi p / 2^k$ for an integer $p$, then we recognize this as $\ket{\psi} = \operatorname{QFT} \ket{p_0 p_1 \dots p_n}$, where $p_j$ is the $j^{\textrm{th}}$ bit of $2 \pi \phi$.</span></span>
<span data-ttu-id="cf356-230">通过应用 "量程傅立叶转换" 的 adjoint，我们将获得编码为量程状态的阶段的二进制表示形式。</span><span class="sxs-lookup"><span data-stu-id="cf356-230">Applying the adjoint of the quantum Fourier transform, we therefore obtain the binary representation of the phase encoded as a quantum state.</span></span>

<span data-ttu-id="cf356-231">在中 Q# ，此 <xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation> 操作由操作实现，该操作采用 <xref:Microsoft.Quantum.Oracles.DiscreteOracle> $U ^ m $ 的实现应用程序作为正整数 $m $ 的函数。</span><span class="sxs-lookup"><span data-stu-id="cf356-231">In Q#, this is implemented by the <xref:Microsoft.Quantum.Characterization.QuantumPhaseEstimation> operation, which takes a <xref:Microsoft.Quantum.Oracles.DiscreteOracle> implementing application of $U^m$ as a function of positive integers $m$.</span></span>
