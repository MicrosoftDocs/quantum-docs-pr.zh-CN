### YamlMime:QSharpType
uid: microsoft.quantum.preparation.quantumrom
name: QuantumROM
type: function
namespace: Microsoft.Quantum.Preparation
summary: >-
  使用量程 ROM 技术来表示给定的密度矩阵。


  给定一个 $N $ 系数 $ \ alpha_j $ 的列表，这将返回一个单一 $U $，该类型使用量程方法为密度矩阵 $ \rho = \ p_j {j = 0} ^ {N-1} \frac{的 purification {j = 0} ^ {sum_ \tilde\rho\} sum_ \ket{j}\bra{j} ${\ sum_k | \ alpha_k |}\ket{j}\bra{j} $。 在此近似中，错误 $ \epsilon $ 是： $ | p_j-\frac{| alpha_j |}{\ sum_k | \ alpha_k |} |\le \epsilon/N $ 和 $\|\tilde\rho-\rho\| \le \epsilon $。 换句话说，$ $ \begin{align} U\ket{0}^ {\Lceil\ log_2 N\rceil} \ 票证{0}^ {m} = \ sum_ {j = 0} ^ {N-1} \sqrt{p_j} \ket{j}\ket{\text{garbage} _j}。

  \end{align} $ $
examples: >-
  下面的代码段准备了 $ 3 $-qubit state $ \rho = \ sum_ {j = 0} ^{4}\frac{| alpha_j |} 的 purification{\ sum_k | \ alpha_k |}\ket{j}\bra{j} $，其中 $ \vec\alpha = （1.0，2.0，3.0，4.0，5.0） $，错误为`1e-3`;


  ```qsharp

  let coefficients = [1.0,2.0,3.0,4.0,5.0];

  let targetError = 1e-3;

  let ((nTotalQubits, (nIndexQubits, nGarbageQubits)), oneNorm, op) = QuantumROM(targetError, coefficients);

  using (indexRegister = Qubit[nIndexQubits]) {
      using (garbageRegister = Qubit[nGarbageQubits]) {
          op(LittleEndian(indexRegister), garbageRegister);
      }
  }

  ```
syntax: 'function QuantumROM (targetError : Double, coefficients : Double[]) : ((Int, (Int, Int)), Double, ((Microsoft.Quantum.Arithmetic.LittleEndian, Qubit[]) => Unit is Adj + Ctl))'
references: '- 通过线性线路编码的电子 Spectra，Ryan Babbush、Craig Gidney、Dominic Berry、Nathan Wiebe、Jarrod McClean、Alexandru 暗、奥斯汀 Fowler、Hartmut Nevenhttps://arxiv.org/abs/1805.03662'
input:
  content: '(targetError : Double, coefficients : Double[])'
  types:
  - name: targetError
    summary: 目标错误 $ \epsilon $。
    isPrimitive: true
    uid: Double
  - name: coefficients
    summary: >-
      $N $ 系数的数组，用于指定基础状态的概率。

      负数 $-\ alpha_j $ 将被视为正 $ | \ alpha_j | $。
    isArray: true
    isPrimitive: true
    uid: Double
output:
  content: ((Int, (Int, Int)), Double, ((Microsoft.Quantum.Arithmetic.LittleEndian, Qubit[]) => Unit is Adj + Ctl))
  types:
  - summary: >-
      ## <a name="first-parameter"></a>第一个参数


      一个元`(x,(y,z))`组`x = y + z` ，其中是所分配的 qubits 总数`y` ，是`LittleEndian`寄存器的 qubits 数， `z`是垃圾 qubits 的数目。


      ## <a name="second-parameter"></a>第二个参数


      系数数组的单规范 $ \ sum_j | \ alpha_j | $。


      ## <a name="third-parameter"></a>第三个参数


      单一 $U $。
    types:
    - types:
      - isPrimitive: true
        uid: Int
      - types:
        - isPrimitive: true
          uid: Int
        - isPrimitive: true
          uid: Int
    - isPrimitive: true
      uid: Double
    - isOperation: true
      input:
        types:
        - uid: microsoft.quantum.arithmetic.littleendian
        - isArray: true
          isPrimitive: true
          uid: Qubit
      output:
        types:
        - isPrimitive: true
          uid: Unit
      functors:
      - Adjoint
      - Controlled
metadata:
  ms.openlocfilehash: 9bf373f0cb7c495f8c29a4426861c74fbb0ec7f6
  ms.sourcegitcommit: db23885adb7ff76cbf8bd1160d401a4f0471e549
  ms.translationtype: MT
  ms.contentlocale: zh-CN
  ms.lasthandoff: 05/01/2020
  ms.locfileid: "82686493"
